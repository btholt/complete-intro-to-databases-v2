{"pageProps":{"post":{"attributes":{"description":"Graph databases are great when you need to define relations between objects that can have complex webs of relations especially for things like social networks."},"html":"<p>This section assumes you&#39;ve inserted all the people and movies from the previous section. If not, <a href=\"https://btholt.github.io/complete-intro-to-databases/sample-neo4j.cql\">run this query</a> to get all the data.</p>\n<p>Let&#39;s do some queries to familiarize ourselves with the data.</p>\n<pre><code class=\"hljs language-cql\">MATCH (n) RETURN distinct labels(n), count(*);\n</code></pre><p>This will query the database for all nodes (which is the <code>(n)</code> part, notice no label) and then it uses the builtin <code>labels()</code> function to get all the labels, and then counts those with <code>count(*)</code> function.</p>\n<pre><code class=\"hljs language-cql\">MATCH (n)-[r]-&gt;() RETURN type(r), count(*);\n</code></pre><p>Similar to above, we are now counting how many relationships we have in a database.</p>\n<p>Okay, so let&#39;s pick an actor or actress and find out what other people they&#39;ve been in movies with. I&#39;ll pick Keanu Reeves here.</p>\n<pre><code class=\"hljs language-cql\">MATCH (Keanu:Person)-[:ACTED_IN]-&gt;(m:Movie)&lt;-[:ACTED_IN]-(Costar:Person)\nWHERE Keanu.name = &quot;Keanu Reeves&quot;\nRETURN DISTINCT Costar.name, count(*)\nORDER BY count(*) DESC, Costar.name;\n</code></pre><ul>\n<li>We&#39;ve seen similar queries before as far as the MATCH goes.</li>\n<li>Similar to above we&#39;re using a DISTINCT clause and then using <code>count(*)</code> to aggregate how many movies Keanu appeared in these movies with these people in.</li>\n<li>ORDER BY should look familiar as it works very similar to PostgreSQL. I gave it two fields to order by so it&#39;ll order first by quantity of films they&#39;re in together then alphabetical by name.</li>\n</ul>\n<p>If you&#39;re using the browser and you want to see a pretty graph, try this:</p>\n<pre><code class=\"hljs language-cql\">MATCH (Keanu:Person)-[:ACTED_IN]-&gt;(m:Movie)&lt;-[r:ACTED_IN]-(Costar:Person)\nWHERE Keanu.name = &quot;Keanu Reeves&quot;\nRETURN Costar, m, Keanu;\n</code></pre><p>If you want the nice graphics you need to return whole nodes and not just fields.</p>\n<h2>Degrees of Kevin Bacon</h2>\n<p>So the whole point of this dataset is to solve the <a href=\"https://en.wikipedia.org/wiki/Six_Degrees_of_Kevin_Bacon\">Six Degrees of Kevin Bacon</a> problem i.e. every actor and actress in Hollywood can be connected Kevin Bacon via them having acted in a film that acted in a film with him directly, with someone who was in a film with Kevin Bacon, or with someone who acted in a film with someone who was in a film with Kevin Bacon, and so-on-and-so-forth up to six degrees of separation.</p>\n<p>So let&#39;s see how you could solve that problem with our dataset. Let&#39;s see how close Keanu is. (run this in the browser)</p>\n<pre><code class=\"hljs language-cql\">MATCH path = shortestPath(\n  (Bacon:Person {name:&quot;Kevin Bacon&quot;})-[*]-(Keanu:Person {name:&quot;Keanu Reeves&quot;})\n)\nRETURN path;\n</code></pre><ul>\n<li><code>shortestPath</code> is a function that will find the shortest path between two nodes by looking at their relationships.</li>\n<li>The variable <code>path</code> ends up being a path type. It contains all the information for a whole path within your grasp.</li>\n<li>You can run this in cypher-shell but it&#39;ll give you a lot of data back.</li>\n</ul>\n<p>For something more friendly to see in cypher-shell, just look at the length</p>\n<pre><code class=\"hljs language-cql\">MATCH path = shortestPath(\n  (Bacon:Person {name:&quot;Kevin Bacon&quot;})-[*]-(Keanu:Person {name:&quot;Keanu Reeves&quot;})\n)\nRETURN length(path);\n</code></pre><p>To unwind this in a way that would be readable in cypher-shell with all the movies and actors/actresses you could do this:</p>\n<pre><code class=\"hljs language-cql\">MATCH path = shortestPath(\n    (First:Person {name:&quot;Kevin Bacon&quot;})-[*]-(Second:Person {name:&quot;Keanu Reeves&quot;})\n)\nUNWIND nodes(path) AS node\nRETURN coalesce(node.name, node.title) AS text;\n</code></pre><ul>\n<li>UNWIND takes something not a list and makes it a list. With <code>nodes(path)</code> we&#39;re getting all the nodes out (which will be Persons and Movies)</li>\n<li><code>coalesce</code> is necessary because Persons have names and Movies have titles. This will take the first thing in there that&#39;s not null.</li>\n<li>We use AS here to make these things easier to refer to later (both <code>node</code> and <code>text</code>)</li>\n</ul>\n<h2>Find Degrees in a Network</h2>\n<p>You could imagine if this was a recommendation engine, you may want to recommend people other actors and actresses based on movies people have appeared in together. What if we wanted to take that two degrees out?</p>\n<pre><code class=\"hljs language-cql\">MATCH (Halle:Person)-[:ACTED_IN*1..4]-(Recommendation:Person)\nWHERE Halle.name = &quot;Halle Berry&quot;\nRETURN DISTINCT Recommendation.name\nORDER BY Recommendation.name;\n</code></pre><p>This will give you that extended network of people to check out. If you wanted to include diretory and writers in that count, just omit the <code>:ACTED_IN</code> so it&#39;s <code>-[*1..4]-</code> and that will give you any relationship.</p>\n","markdown":"\nThis section assumes you've inserted all the people and movies from the previous section. If not, [run this query][sample] to get all the data.\n\nLet's do some queries to familiarize ourselves with the data.\n\n```cql\nMATCH (n) RETURN distinct labels(n), count(*);\n```\n\nThis will query the database for all nodes (which is the `(n)` part, notice no label) and then it uses the builtin `labels()` function to get all the labels, and then counts those with `count(*)` function.\n\n```cql\nMATCH (n)-[r]->() RETURN type(r), count(*);\n```\n\nSimilar to above, we are now counting how many relationships we have in a database.\n\nOkay, so let's pick an actor or actress and find out what other people they've been in movies with. I'll pick Keanu Reeves here.\n\n```cql\nMATCH (Keanu:Person)-[:ACTED_IN]->(m:Movie)<-[:ACTED_IN]-(Costar:Person)\nWHERE Keanu.name = \"Keanu Reeves\"\nRETURN DISTINCT Costar.name, count(*)\nORDER BY count(*) DESC, Costar.name;\n```\n\n- We've seen similar queries before as far as the MATCH goes.\n- Similar to above we're using a DISTINCT clause and then using `count(*)` to aggregate how many movies Keanu appeared in these movies with these people in.\n- ORDER BY should look familiar as it works very similar to PostgreSQL. I gave it two fields to order by so it'll order first by quantity of films they're in together then alphabetical by name.\n\nIf you're using the browser and you want to see a pretty graph, try this:\n\n```cql\nMATCH (Keanu:Person)-[:ACTED_IN]->(m:Movie)<-[r:ACTED_IN]-(Costar:Person)\nWHERE Keanu.name = \"Keanu Reeves\"\nRETURN Costar, m, Keanu;\n```\n\nIf you want the nice graphics you need to return whole nodes and not just fields.\n\n## Degrees of Kevin Bacon\n\nSo the whole point of this dataset is to solve the [Six Degrees of Kevin Bacon][bacon] problem i.e. every actor and actress in Hollywood can be connected Kevin Bacon via them having acted in a film that acted in a film with him directly, with someone who was in a film with Kevin Bacon, or with someone who acted in a film with someone who was in a film with Kevin Bacon, and so-on-and-so-forth up to six degrees of separation.\n\nSo let's see how you could solve that problem with our dataset. Let's see how close Keanu is. (run this in the browser)\n\n```cql\nMATCH path = shortestPath(\n  (Bacon:Person {name:\"Kevin Bacon\"})-[*]-(Keanu:Person {name:\"Keanu Reeves\"})\n)\nRETURN path;\n```\n\n- `shortestPath` is a function that will find the shortest path between two nodes by looking at their relationships.\n- The variable `path` ends up being a path type. It contains all the information for a whole path within your grasp.\n- You can run this in cypher-shell but it'll give you a lot of data back.\n\nFor something more friendly to see in cypher-shell, just look at the length\n\n```cql\nMATCH path = shortestPath(\n  (Bacon:Person {name:\"Kevin Bacon\"})-[*]-(Keanu:Person {name:\"Keanu Reeves\"})\n)\nRETURN length(path);\n```\n\nTo unwind this in a way that would be readable in cypher-shell with all the movies and actors/actresses you could do this:\n\n```cql\nMATCH path = shortestPath(\n    (First:Person {name:\"Kevin Bacon\"})-[*]-(Second:Person {name:\"Keanu Reeves\"})\n)\nUNWIND nodes(path) AS node\nRETURN coalesce(node.name, node.title) AS text;\n```\n\n- UNWIND takes something not a list and makes it a list. With `nodes(path)` we're getting all the nodes out (which will be Persons and Movies)\n- `coalesce` is necessary because Persons have names and Movies have titles. This will take the first thing in there that's not null.\n- We use AS here to make these things easier to refer to later (both `node` and `text`)\n\n## Find Degrees in a Network\n\nYou could imagine if this was a recommendation engine, you may want to recommend people other actors and actresses based on movies people have appeared in together. What if we wanted to take that two degrees out?\n\n```cql\nMATCH (Halle:Person)-[:ACTED_IN*1..4]-(Recommendation:Person)\nWHERE Halle.name = \"Halle Berry\"\nRETURN DISTINCT Recommendation.name\nORDER BY Recommendation.name;\n```\n\nThis will give you that extended network of people to check out. If you wanted to include diretory and writers in that count, just omit the `:ACTED_IN` so it's `-[*1..4]-` and that will give you any relationship.\n\n[sample]: https://btholt.github.io/complete-intro-to-databases/sample-neo4j.cql\n[bacon]: https://en.wikipedia.org/wiki/Six_Degrees_of_Kevin_Bacon\n","slug":"complex-neo4j-queries","title":"Complex Neo4j Queries","section":"Graph","icon":"info-circle","filePath":"/home/runner/work/complete-intro-to-databases-v2/complete-intro-to-databases-v2/lessons/04-graph/D-complex-neo4j-queries.md","nextSlug":"/lessons/graph/indexes-in-neo4j","prevSlug":"/lessons/graph/neo4j-browser"}},"__N_SSG":true}