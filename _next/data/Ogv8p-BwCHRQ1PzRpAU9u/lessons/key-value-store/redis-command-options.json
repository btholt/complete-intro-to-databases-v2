{"pageProps":{"post":{"attributes":{"description":"Useful when using Redis is the ability to define when documents get deleted with TTLs and when a query will fail with NX and XX."},"html":"<h2>NX and XX</h2>\n<p>These allow you to tell Redis &quot;fail if this key already exists&quot; or &quot;fail if this key doesn&#39;t already exists&quot;. Occasionally this can be helpful.</p>\n<p>Note the <code>#</code> comments aren&#39;t valid so don&#39;t copy and paste those parts.</p>\n<pre><code class=\"hljs language-redis\">SET color blue XX # fails because it doesn&#x27;t exist yet\nSET color blue NX # succeeds because it didn&#x27;t exist\nSET color blue XX # succeeds because it does exist\nSET color blue NX # fails because it does exist\n</code></pre><p>Just thing that <code>NX</code> is succeeds when <strong>n</strong>ot e<strong>x</strong>ists and <code>XX</code> is the other one.</p>\n<p>You could actually re-implement our plane explorer above with this.</p>\n<pre><code class=\"hljs language-redis\">SET plane:0:0 visited NX # succeeds\nSET plane:1:0 visited NX # succeeds\nSET plane:0:0 visited NX # fails\nSET plane:1:1 visited NX # succeeds\n</code></pre><p>And now you can just track if a read/write fails or succeeds to know if you&#39;ve been there before.</p>\n<h2>TTL</h2>\n<p>TTL stands for <strong>t</strong>ime <strong>t</strong>o <strong>l</strong>ive. The idea here is you can put an expiration on a key in Redis and after that time Redis will automatically clean up the record for you. MongoDB and PostgreSQL also possess this ability but it becomes essential to caching.</p>\n<p>Let&#39;s say you run a fitness app and a user wants to see all their fitness statistics for their workouts. Let&#39;s say this calculation is fairly expensive to do so it&#39;d be better if we didn&#39;t do it multiple times a minute if a user refreshes the page. And typically that data doesn&#39;t update so frequently; people don&#39;t work out all the time. Yet after an hour or so that data is stale: our users want to see fairly up to date information. We could do this:</p>\n<pre><code class=\"hljs language-redis\">SET fitness:total:btholt 750kj EX 3600\n</code></pre><p>This will set the key of <code>fitness:total:btholt</code> to expire after an hour after which it&#39;ll delete itself. Think of <code>EX</code> meaning expires. EX is always in seconds. Then in your code you&#39;ll first try to grab the cache. If something is there, it means it&#39;s still valid so go ahead and serve that. If it&#39;s not there, it means you need to recalculate it and you go ahead and do it right then.</p>\n<p>There is also <code>PX</code> if you need milliseconds.</p>\n<p>If you want to see it in action, try this.</p>\n<pre><code class=\"hljs language-redis\">SET test_expire hi EX 5\nEXISTS test_expire\n</code></pre><h2>Thundering herd</h2>\n<p>A word of caution: the <em>thundering herd</em> problem is something to consider. Let&#39;s say that 1,000 users hit that page all at the same time when the cache has expired. Our server will miss the cache 1,000 times and try to calculate the response 1,000 times. This is referred to as the thundering herd problem. Caching is difficult business. It&#39;s not a huge possibility here because we&#39;re just targeting one user but if it was a real possibility that multiple users could hit a cache miss then you need to mitigate that. A good way is that the server <em>only</em> reads from the cache and then a separate background job updates the cache automatically (and thus you wouldn&#39;t use TTLs at all.)</p>\n<p>After five seconds EXISTS will return false. Very useful for all sorts of caching strategies.</p>\n","markdown":"\n## NX and XX\n\nThese allow you to tell Redis \"fail if this key already exists\" or \"fail if this key doesn't already exists\". Occasionally this can be helpful.\n\nNote the `#` comments aren't valid so don't copy and paste those parts.\n\n```redis\nSET color blue XX # fails because it doesn't exist yet\nSET color blue NX # succeeds because it didn't exist\nSET color blue XX # succeeds because it does exist\nSET color blue NX # fails because it does exist\n```\n\nJust thing that `NX` is succeeds when **n**ot e**x**ists and `XX` is the other one.\n\nYou could actually re-implement our plane explorer above with this.\n\n```redis\nSET plane:0:0 visited NX # succeeds\nSET plane:1:0 visited NX # succeeds\nSET plane:0:0 visited NX # fails\nSET plane:1:1 visited NX # succeeds\n```\n\nAnd now you can just track if a read/write fails or succeeds to know if you've been there before.\n\n## TTL\n\nTTL stands for **t**ime **t**o **l**ive. The idea here is you can put an expiration on a key in Redis and after that time Redis will automatically clean up the record for you. MongoDB and PostgreSQL also possess this ability but it becomes essential to caching.\n\nLet's say you run a fitness app and a user wants to see all their fitness statistics for their workouts. Let's say this calculation is fairly expensive to do so it'd be better if we didn't do it multiple times a minute if a user refreshes the page. And typically that data doesn't update so frequently; people don't work out all the time. Yet after an hour or so that data is stale: our users want to see fairly up to date information. We could do this:\n\n```redis\nSET fitness:total:btholt 750kj EX 3600\n```\n\nThis will set the key of `fitness:total:btholt` to expire after an hour after which it'll delete itself. Think of `EX` meaning expires. EX is always in seconds. Then in your code you'll first try to grab the cache. If something is there, it means it's still valid so go ahead and serve that. If it's not there, it means you need to recalculate it and you go ahead and do it right then.\n\nThere is also `PX` if you need milliseconds.\n\nIf you want to see it in action, try this.\n\n```redis\nSET test_expire hi EX 5\nEXISTS test_expire\n```\n\n## Thundering herd\n\nA word of caution: the _thundering herd_ problem is something to consider. Let's say that 1,000 users hit that page all at the same time when the cache has expired. Our server will miss the cache 1,000 times and try to calculate the response 1,000 times. This is referred to as the thundering herd problem. Caching is difficult business. It's not a huge possibility here because we're just targeting one user but if it was a real possibility that multiple users could hit a cache miss then you need to mitigate that. A good way is that the server _only_ reads from the cache and then a separate background job updates the cache automatically (and thus you wouldn't use TTLs at all.)\n\nAfter five seconds EXISTS will return false. Very useful for all sorts of caching strategies.\n","slug":"redis-command-options","title":"Redis Command Options","section":"Key Value Store","icon":"info-circle","filePath":"/home/runner/work/complete-intro-to-databases-v2/complete-intro-to-databases-v2/lessons/05-key-value-store/C-redis-command-options.md","nextSlug":"/lessons/key-value-store/redis-data-types","prevSlug":"/lessons/key-value-store/redis"}},"__N_SSG":true}