{"pageProps":{"post":{"attributes":{"title":"JSON in PostgreSQL","description":"One of PostgreSQL's super powers is that it's able to store and query JSON"},"html":"<h2>Error in this course</h2>\n<p>This course incorrectly chooses to use the <code>JSON</code> data type when it should have used the <code>JSONB</code> data type. Everything in this course will work with either one but when you&#39;re creating your own database you almost always (let&#39;s just say always) want to choose JSONB because it stores the data in a more queryable format and more optimized for querying whereas JSON is a glorified text field. So feel free to use <code>JSONB</code> everywhere where it says <code>JSON</code> or you can just use <code>JSON</code> knowing that when you go do it for yourself you&#39;re going to use <code>JSONB</code>. I&#39;ve correct the references in this doc from JSON to JSONB but the videos will still says JSON.</p>\n<p><a href=\"https://www.citusdata.com/blog/2016/07/14/choosing-nosql-hstore-json-jsonb/\">For more info read this blog post about it</a>.</p>\n<h2>JSON</h2>\n<p>Sometimes you have data that just doesn&#39;t have a nice schema to it. If you tried to fit it into a table database like PostgreSQL, you would end having very generic field names that would have to be interprepted by code or you&#39;d end up with multiple tables to be able describe different schemas. This is one place where document based databases like MongoDB really shine; their schemaless database works really well in these situations.</p>\n<p>However PostgreSQL has a magic superpower here: the JSONB data type. This allows you to put JSONB objects into a column and then you can use SQL to query those objects.</p>\n<p>Let&#39;s make an example for our message board. You want to add a new feature that allows users to do rich content embeds in your message board. For starters they&#39;ll be able to embed polls, images, and videos but you can imagine growing that in the future so they can embed tweets, documents, and other things we haven&#39;t dreamed up yet. You want to maintain that future flexibility.</p>\n<p>This would be possible to model with a normal schema but it&#39;d come out pretty ugly and hard to understand, and it&#39;s impossible to anticipate all our future growth plans now. This is where the <code>JSONB</code> data type is going to really shine. These are the queries we ran to create them. (you don&#39;t need to run them again)</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">DROP</span> <span class=\"hljs-keyword\">TABLE</span> IF <span class=\"hljs-keyword\">EXISTS</span> rich_content;\n\n<span class=\"hljs-keyword\">CREATE TABLE</span> rich_content (\n  content_id <span class=\"hljs-type\">INTEGER</span> <span class=\"hljs-keyword\">PRIMARY KEY</span> GENERATED ALWAYS <span class=\"hljs-keyword\">AS</span> <span class=\"hljs-keyword\">IDENTITY</span>,\n  comment_id <span class=\"hljs-type\">INT</span> <span class=\"hljs-keyword\">REFERENCES</span> comments(comment_id) <span class=\"hljs-keyword\">ON</span> <span class=\"hljs-keyword\">DELETE</span> CASCADE,\n  content JSONB <span class=\"hljs-keyword\">NOT NULL</span>\n);\n\n<span class=\"hljs-keyword\">INSERT INTO</span> rich_content\n  (comment_id, content)\n<span class=\"hljs-keyword\">VALUES</span>\n  (<span class=\"hljs-number\">63</span>, <span class=\"hljs-string\">&#x27;{ &quot;type&quot;: &quot;poll&quot;, &quot;question&quot;: &quot;What is your favorite color?&quot;, &quot;options&quot;: [&quot;blue&quot;, &quot;red&quot;, &quot;green&quot;, &quot;yellow&quot;] }&#x27;</span>),\n  (<span class=\"hljs-number\">358</span>, <span class=\"hljs-string\">&#x27;{ &quot;type&quot;: &quot;video&quot;, &quot;url&quot;: &quot;https://youtu.be/dQw4w9WgXcQ&quot;, &quot;dimensions&quot;: { &quot;height&quot;: 1080, &quot;width&quot;: 1920 }}&#x27;</span>),\n  (<span class=\"hljs-number\">358</span>, <span class=\"hljs-string\">&#x27;{ &quot;type&quot;: &quot;poll&quot;, &quot;question&quot;: &quot;Is this your favorite video?&quot;, &quot;options&quot;: [&quot;yes&quot;, &quot;no&quot;, &quot;oh you&quot;] }&#x27;</span>),\n  (<span class=\"hljs-number\">410</span>, <span class=\"hljs-string\">&#x27;{ &quot;type&quot;: &quot;image&quot;, &quot;url&quot;: &quot;https://btholt.github.io/complete-intro-to-linux-and-the-cli/WORDMARK-Small.png&quot;, &quot;dimensions&quot;: { &quot;height&quot;: 400, &quot;width&quot;: 1084 }}&#x27;</span>),\n  (<span class=\"hljs-number\">485</span>, <span class=\"hljs-string\">&#x27;{ &quot;type&quot;: &quot;image&quot;, &quot;url&quot;: &quot;https://btholt.github.io/complete-intro-to-linux-and-the-cli/HEADER.png&quot;, &quot;dimensions&quot;: { &quot;height&quot;: 237 , &quot;width&quot;: 3301 }}&#x27;</span>);\n</code></pre><ul>\n<li>The <code>JSONB</code> data type is the shining star here. This allows us to insert JSON objects to be queried later.</li>\n<li>PostgreSQL won&#39;t let you insert malformatted JSON so it does validate it for you.</li>\n<li>Notice you can have as much nesting as you want. Any valid JSON is valid here.</li>\n</ul>\n<p>So let&#39;s do some querying! We&#39;re going to use two new symbols, <code>-&gt;</code> and <code>-&gt;&gt;</code>. The <code>-&gt;</code> means &quot;give me back the JSON object&quot;. The return type will be a JSON object, even if it&#39;s just a string. It&#39;s basically a black box to PostgreSQL and it treats all JSON the same, whether it&#39;s an array, object, or just a string. The <code>-&gt;&gt;</code> means &quot;give me this back as a string.&quot;</p>\n<p>Find the all the different types of rich content.</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">SELECT</span> content <span class=\"hljs-operator\">-</span><span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-string\">&#x27;type&#x27;</span> <span class=\"hljs-keyword\">FROM</span> rich_content;\n</code></pre><p>You&#39;ll get something like this</p>\n<pre><code class=\"hljs language-md\"><span class=\"hljs-section\">## ?column?</span>\n\n&quot;poll&quot;\n&quot;video&quot;\n&quot;poll&quot;\n&quot;image&quot;\n&quot;image&quot;\n</code></pre><p>It repeats poll and image twice because there&#39;s two of those. What if we just wanted the distinct options and no repeats? GROUP BY would work but let&#39;s detour to talk about <code>SELECT DISTINCT</code>. SELECT DISTINCT will deduplicate your results for you. Try this (this will error)</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-keyword\">DISTINCT</span> content <span class=\"hljs-operator\">-</span><span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-string\">&#x27;type&#x27;</span> <span class=\"hljs-keyword\">FROM</span> rich_content;\n</code></pre><p>PostgreSQL doesn&#39;t actually know what data type it&#39;s going to get back from JSON so it refuses to do any sort of comparisons with the results. We have to tell PostgreSQL &quot;this is definitely going to be text.</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-keyword\">DISTINCT</span> <span class=\"hljs-built_in\">CAST</span>(content <span class=\"hljs-operator\">-</span><span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-string\">&#x27;type&#x27;</span> <span class=\"hljs-keyword\">AS</span> TEXT) <span class=\"hljs-keyword\">FROM</span> rich_content;\n</code></pre><p>However this is a ton easier if you just <code>-&gt;&gt;</code></p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-keyword\">DISTINCT</span> content <span class=\"hljs-operator\">-</span><span class=\"hljs-operator\">&gt;&gt;</span> <span class=\"hljs-string\">&#x27;type&#x27;</span> <span class=\"hljs-keyword\">FROM</span> rich_content;\n</code></pre><p>That&#39;s the key difference between <code>-&gt;</code> and <code>-&gt;&gt;</code>.</p>\n<p>What if we wanted to only query for polls?</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">SELECT</span> content <span class=\"hljs-operator\">-</span><span class=\"hljs-operator\">&gt;&gt;</span> <span class=\"hljs-string\">&#x27;type&#x27;</span> <span class=\"hljs-keyword\">AS</span> content_type, comment_id <span class=\"hljs-keyword\">FROM</span> rich_content <span class=\"hljs-keyword\">WHERE</span> content <span class=\"hljs-operator\">-</span><span class=\"hljs-operator\">&gt;&gt;</span> <span class=\"hljs-string\">&#x27;type&#x27;</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;poll&#x27;</span>;\n</code></pre><p>Unfortunately due to the execution order (WHERE happens before SELECT) you can&#39;t reference content_type and have to give it the full expression.</p>\n<p>Okay, last one. What if we wanted to find all the widths and heights?</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">SELECT</span>\n  content <span class=\"hljs-operator\">-</span><span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-string\">&#x27;dimensions&#x27;</span> <span class=\"hljs-operator\">-</span><span class=\"hljs-operator\">&gt;&gt;</span> <span class=\"hljs-string\">&#x27;height&#x27;</span> <span class=\"hljs-keyword\">AS</span> height,\n  content <span class=\"hljs-operator\">-</span><span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-string\">&#x27;dimensions&#x27;</span> <span class=\"hljs-operator\">-</span><span class=\"hljs-operator\">&gt;&gt;</span> <span class=\"hljs-string\">&#x27;width&#x27;</span> <span class=\"hljs-keyword\">AS</span> width,\n  comment_id\n<span class=\"hljs-keyword\">FROM</span>\n  rich_content;\n</code></pre><p>You can use the <code>-&gt;</code> and <code>-&gt;&gt;</code> multiple times to look at nested values. This will give you back the ones that don&#39;t have heights and widths too. To filter those out just do:</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">SELECT</span>\n  content <span class=\"hljs-operator\">-</span><span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-string\">&#x27;dimensions&#x27;</span> <span class=\"hljs-operator\">-</span><span class=\"hljs-operator\">&gt;&gt;</span> <span class=\"hljs-string\">&#x27;height&#x27;</span> <span class=\"hljs-keyword\">AS</span> height,\n  content <span class=\"hljs-operator\">-</span><span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-string\">&#x27;dimensions&#x27;</span> <span class=\"hljs-operator\">-</span><span class=\"hljs-operator\">&gt;&gt;</span> <span class=\"hljs-string\">&#x27;width&#x27;</span> <span class=\"hljs-keyword\">AS</span> width,\n  comment_id\n<span class=\"hljs-keyword\">FROM</span>\n  rich_content\n<span class=\"hljs-keyword\">WHERE</span>\n  content <span class=\"hljs-operator\">-</span><span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-string\">&#x27;dimensions&#x27;</span> <span class=\"hljs-keyword\">IS</span> <span class=\"hljs-keyword\">NOT NULL</span>;\n</code></pre>","markdown":"\n## Error in this course\n\nThis course incorrectly chooses to use the `JSON` data type when it should have used the `JSONB` data type. Everything in this course will work with either one but when you're creating your own database you almost always (let's just say always) want to choose JSONB because it stores the data in a more queryable format and more optimized for querying whereas JSON is a glorified text field. So feel free to use `JSONB` everywhere where it says `JSON` or you can just use `JSON` knowing that when you go do it for yourself you're going to use `JSONB`. I've correct the references in this doc from JSON to JSONB but the videos will still says JSON.\n\n[For more info read this blog post about it][jsonb].\n\n## JSON\n\nSometimes you have data that just doesn't have a nice schema to it. If you tried to fit it into a table database like PostgreSQL, you would end having very generic field names that would have to be interprepted by code or you'd end up with multiple tables to be able describe different schemas. This is one place where document based databases like MongoDB really shine; their schemaless database works really well in these situations.\n\nHowever PostgreSQL has a magic superpower here: the JSONB data type. This allows you to put JSONB objects into a column and then you can use SQL to query those objects.\n\nLet's make an example for our message board. You want to add a new feature that allows users to do rich content embeds in your message board. For starters they'll be able to embed polls, images, and videos but you can imagine growing that in the future so they can embed tweets, documents, and other things we haven't dreamed up yet. You want to maintain that future flexibility.\n\nThis would be possible to model with a normal schema but it'd come out pretty ugly and hard to understand, and it's impossible to anticipate all our future growth plans now. This is where the `JSONB` data type is going to really shine. These are the queries we ran to create them. (you don't need to run them again)\n\n```sql\nDROP TABLE IF EXISTS rich_content;\n\nCREATE TABLE rich_content (\n  content_id INTEGER PRIMARY KEY GENERATED ALWAYS AS IDENTITY,\n  comment_id INT REFERENCES comments(comment_id) ON DELETE CASCADE,\n  content JSONB NOT NULL\n);\n\nINSERT INTO rich_content\n  (comment_id, content)\nVALUES\n  (63, '{ \"type\": \"poll\", \"question\": \"What is your favorite color?\", \"options\": [\"blue\", \"red\", \"green\", \"yellow\"] }'),\n  (358, '{ \"type\": \"video\", \"url\": \"https://youtu.be/dQw4w9WgXcQ\", \"dimensions\": { \"height\": 1080, \"width\": 1920 }}'),\n  (358, '{ \"type\": \"poll\", \"question\": \"Is this your favorite video?\", \"options\": [\"yes\", \"no\", \"oh you\"] }'),\n  (410, '{ \"type\": \"image\", \"url\": \"https://btholt.github.io/complete-intro-to-linux-and-the-cli/WORDMARK-Small.png\", \"dimensions\": { \"height\": 400, \"width\": 1084 }}'),\n  (485, '{ \"type\": \"image\", \"url\": \"https://btholt.github.io/complete-intro-to-linux-and-the-cli/HEADER.png\", \"dimensions\": { \"height\": 237 , \"width\": 3301 }}');\n```\n\n- The `JSONB` data type is the shining star here. This allows us to insert JSON objects to be queried later.\n- PostgreSQL won't let you insert malformatted JSON so it does validate it for you.\n- Notice you can have as much nesting as you want. Any valid JSON is valid here.\n\nSo let's do some querying! We're going to use two new symbols, `->` and `->>`. The `->` means \"give me back the JSON object\". The return type will be a JSON object, even if it's just a string. It's basically a black box to PostgreSQL and it treats all JSON the same, whether it's an array, object, or just a string. The `->>` means \"give me this back as a string.\"\n\nFind the all the different types of rich content.\n\n```sql\nSELECT content -> 'type' FROM rich_content;\n```\n\nYou'll get something like this\n\n```md\n## ?column?\n\n\"poll\"\n\"video\"\n\"poll\"\n\"image\"\n\"image\"\n```\n\nIt repeats poll and image twice because there's two of those. What if we just wanted the distinct options and no repeats? GROUP BY would work but let's detour to talk about `SELECT DISTINCT`. SELECT DISTINCT will deduplicate your results for you. Try this (this will error)\n\n```sql\nSELECT DISTINCT content -> 'type' FROM rich_content;\n```\n\nPostgreSQL doesn't actually know what data type it's going to get back from JSON so it refuses to do any sort of comparisons with the results. We have to tell PostgreSQL \"this is definitely going to be text.\n\n```sql\nSELECT DISTINCT CAST(content -> 'type' AS TEXT) FROM rich_content;\n```\n\nHowever this is a ton easier if you just `->>`\n\n```sql\nSELECT DISTINCT content ->> 'type' FROM rich_content;\n```\n\nThat's the key difference between `->` and `->>`.\n\nWhat if we wanted to only query for polls?\n\n```sql\nSELECT content ->> 'type' AS content_type, comment_id FROM rich_content WHERE content ->> 'type' = 'poll';\n```\n\nUnfortunately due to the execution order (WHERE happens before SELECT) you can't reference content_type and have to give it the full expression.\n\nOkay, last one. What if we wanted to find all the widths and heights?\n\n```sql\nSELECT\n  content -> 'dimensions' ->> 'height' AS height,\n  content -> 'dimensions' ->> 'width' AS width,\n  comment_id\nFROM\n  rich_content;\n```\n\nYou can use the `->` and `->>` multiple times to look at nested values. This will give you back the ones that don't have heights and widths too. To filter those out just do:\n\n```sql\nSELECT\n  content -> 'dimensions' ->> 'height' AS height,\n  content -> 'dimensions' ->> 'width' AS width,\n  comment_id\nFROM\n  rich_content\nWHERE\n  content -> 'dimensions' IS NOT NULL;\n```\n\n[jsonb]: https://www.citusdata.com/blog/2016/07/14/choosing-nosql-hstore-json-jsonb/\n","slug":"json-in-postgresql","title":"JSON in PostgreSQL","section":"Sql","icon":"info-circle","filePath":"/home/runner/work/complete-intro-to-databases-v2/complete-intro-to-databases-v2/lessons/03-sql/E-json-in-postgresql.md","nextSlug":"/lessons/sql/indexes-in-postgresql","prevSlug":"/lessons/sql/complex-sql-queries"}},"__N_SSG":true}