{"pageProps":{"post":{"attributes":{"title":"PostgreSQL","description":"PostgreSQL is a relational database that lets developers write amazing apps. Brian goes over how to get PostgreSQL started on your computer and help you write your first query."},"html":"<p>So we examined a bit of the general relational databases in the previous section, let&#39;s get into some interacting with some databases.</p>\n<h2>Let&#39;s get PostgreSQL going</h2>\n<p>Let&#39;s start by getting a PostgreSQL container going. I&#39;m going to use version 13.0 (the latest container available) and I&#39;d recommend for this tutorial you do the same. While newer ones might be available, this is the one that will work with this tutorial.</p>\n<pre><code class=\"hljs language-bash\">docker run --name my-postgres -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d --<span class=\"hljs-built_in\">rm</span> postgres:13.0\n\ndocker <span class=\"hljs-built_in\">exec</span> -it -u postgres my-postgres psql\n</code></pre><p>We have to give it a password or PostgreSQL won&#39;t start by default. Don&#39;t worry, this isn&#39;t how&#39;d you start it in production.</p>\n<p>At this point you should</p>\n<h2>Databases and Tables</h2>\n<p>PostgreSQL has the same concept of databases as MongoDB. This will be a group of tables that are related to similar problem-area. It&#39;ll be up to you how you choose to group these. Some apps are focused enough to all be in one database; others will need many databases. It&#39;s up to you and your data architect to figure out how to do that. In general, things that should be scaled separately (like maybe payment transactions and items in your store?)</p>\n<p>Tables are similar to collections. This will be a group of records. It&#39;s like one Excel spreadsheet. A record is like an object in MongoDB. It&#39;s one thing in a table. One record would be a user in the users database.</p>\n<p>Tables will have a defined schema. Like in Excel, one column will reprent one bit of information, so too will a field in a record represent one bit of information. As opposed to MongoDB, this schema has to be defined in advance and cannot be done on the fly. Altering a table&#39;s schema is a hefty operation and on big tables can literally takes hours or days to do. Forethought is a lot more important here.</p>\n<p>This is a simple intro to this. There&#39;s a lot more to this but we&#39;ll get into as we go through our defined example.</p>\n<h2>Our first SQL queries</h2>\n<p>The first order of business it create a new database. And we&#39;re going to do that using SQL. All SQL is fairly similar but are not necessarily drop-in compatible with each other. So while this would be similar in getting started to MySQL, it wouldn&#39;t be identical.</p>\n<p>First thing you&#39;ll notice is I&#39;ll capitlize all the key words. This is to make reading the query easier, you can see what&#39;s a key word and what&#39;s not at a glance. And moreover it&#39;s just common to do so I stick with common best practices.</p>\n<p>By default you connect to database &quot;postgres&quot; which is just a default database name. Let&#39;s make our own called <code>message_board</code>.</p>\n<p>So go ahead and run your first query here to create a new database. <strong>Make sure you include the <code>;</code> at the end.</strong> While the semi-colon is optional in JS it is not in SQL! It thinks you&#39;re still going until you include that <code>;</code>.</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">CREATE</span> DATABASE message_boards;\n</code></pre><p>You should see <code>CREATE DATABASE</code> underneath that as a confirmation that it went through. Great! Now we have a new database to switch to, so let&#39;s do that.</p>\n<pre><code class=\"hljs language-sql\">\\c message_boards;\n<span class=\"hljs-comment\">-- \\connect message_boards works too</span>\n</code></pre><p>This <code>\\</code> notation is how you give admin commands to PostgreSQL through its <code>psql</code> CLI which is what we&#39;re using right now. In this case we&#39;re saying connect to this new database. Let&#39;s try a few other commands real quick!</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-comment\">-- see all databases</span>\n\\l\n\n<span class=\"hljs-comment\">-- see all tables in this database, probably won&#x27;t see anything</span>\n\\d\n\n<span class=\"hljs-comment\">-- see all available commands</span>\n\\?\n\n<span class=\"hljs-comment\">-- see available queries</span>\n\\h\n\n<span class=\"hljs-comment\">-- run a shell command</span>\n\\<span class=\"hljs-operator\">!</span> ls <span class=\"hljs-operator\">&amp;&amp;</span> echo &quot;hi from shell!&quot;\n</code></pre><p>In case you didn&#39;t know, <code>--</code> is how you do comments in SQL.</p>\n<h2>First table</h2>\n<p>Okay, so now we have a database and we&#39;re connected to it, let&#39;s create our first table.</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">CREATE TABLE</span> users (\n  user_id <span class=\"hljs-type\">INTEGER</span> <span class=\"hljs-keyword\">PRIMARY KEY</span> GENERATED ALWAYS <span class=\"hljs-keyword\">AS</span> <span class=\"hljs-keyword\">IDENTITY</span>,\n  username <span class=\"hljs-type\">VARCHAR</span> ( <span class=\"hljs-number\">25</span> ) <span class=\"hljs-keyword\">UNIQUE</span> <span class=\"hljs-keyword\">NOT NULL</span>,\n  email <span class=\"hljs-type\">VARCHAR</span> ( <span class=\"hljs-number\">50</span> ) <span class=\"hljs-keyword\">UNIQUE</span> <span class=\"hljs-keyword\">NOT NULL</span>,\n  full_name <span class=\"hljs-type\">VARCHAR</span> ( <span class=\"hljs-number\">100</span> ) <span class=\"hljs-keyword\">NOT NULL</span>,\n  last_login <span class=\"hljs-type\">TIMESTAMP</span>,\n  created_on <span class=\"hljs-type\">TIMESTAMP</span> <span class=\"hljs-keyword\">NOT NULL</span>\n);\n</code></pre><p>So let&#39;s break this down</p>\n<ul>\n<li>CREATE TABLE is the command we&#39;ll use to create a new table. We&#39;re naming it the users table</li>\n<li><code>user_id</code> will be an incrementing field The first users will have a user_if of 1, the second one will have user_id of 2, etc. That&#39;s what the <code>GENERATED ALWAYS AS IDENTITY</code> means. It&#39;s autoincrementing. The PRIMARY KEY part means it&#39;s what the table will be indexed on which means inherently that it is indexed.</li>\n<li>Previously PostgreSQL used a field type called <code>SERIAL</code> to describe the serially incrementing IDs. The <code>GENERATED AS ALWAYS</code> syntax is newer, more compliant to the generic SQL spec, and works better. Always use it over <code>SERIAL</code>.</li>\n<li>Before, in MongoDB, we relied on the <code>_id</code> field to be that key field. PostgreSQL doesn&#39;t do that for you by default.</li>\n<li>We created two VARCHARS which is the SQL way of saying string. The username will have a character limit of 25 and the email will have a charcter limit of 50. Each of them will be guaranteed unique (thanks to UNIQUE) and to not be omitted (thanks to NOT NULL).</li>\n<li>They could still be empty strings with NOT NULL but you&#39;d have to intentionally specify that.</li>\n<li>full_name is not unique so you could have two Sally Rogers.</li>\n<li>We our last_login field it will be the last time the user logged in. We could use this later to clean out inactive accounts. Notice this doesn&#39;t have NOT NULL so when we create a new user they can have a null login time because they haven&#39;t logged in yet.</li>\n<li>Lastly we&#39;ll provide it with a date via the created_on field so we can keep track of when a user was created.</li>\n</ul>\n<p>We won&#39;t be going into too many more PostgreSQL data types but there are a lot. <a href=\"https://www.postgresql.org/docs/9.5/datatype.html#DATATYPE-TABLE\">See here</a>.</p>\n<h2>First record</h2>\n<p>Let&#39;s insert a user into our new table. This is like adding a new row into a spreadsheet.</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">INSERT INTO</span> users (username, email, full_name, created_on) <span class=\"hljs-keyword\">VALUES</span> (<span class=\"hljs-string\">&#x27;btholt&#x27;</span>, <span class=\"hljs-string\">&#x27;lol@example.com&#x27;</span>, <span class=\"hljs-string\">&#x27;Brian Holt&#x27;</span>, NOW());\n</code></pre><ul>\n<li>This is how you insert a new record into a relational database.</li>\n<li>The <code>INSERT INTO</code> tells the SQL engine you&#39;re going to be doing an insert, and we&#39;re doing it into <code>users</code>.</li>\n<li>The <code>()</code> is where you provide the order you&#39;re going to be giving the fields to PostgreSQL in the VALUES part.</li>\n<li>Notice we&#39;re not providing user_id since PostgreSQL will provide that itself.</li>\n<li>We&#39;re also not providing a <code>last_login</code> time because it&#39;s not required and in theory the user hasn&#39;t logged in yet.</li>\n<li>For the created_on, we&#39;re using a special PostgreSQL built in function called <code>NOW()</code>. This provide the current time as a parameter in that space.</li>\n</ul>\n<p>You should see <code>INSERT 0 1</code> to let you know that the query succeeded. The 1 represents that 1 record was inserted successfully and the 0 represents the OID which we&#39;re not covering nor using and will be 0 for us throughout our course i.e. no need to worry about it.</p>\n<h2>See your first record</h2>\n<p>We&#39;re about to get into more advance querying but I want you to see the fruits of your labor! Run this query to fetch every record and every field from a table</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> users;\n</code></pre><p>You should see your one row you&#39;ve inserted! Good job! You&#39;re off to a great start. We&#39;ll go over the query we just ran in the next section.</p>\n","markdown":"\nSo we examined a bit of the general relational databases in the previous section, let's get into some interacting with some databases.\n\n## Let's get PostgreSQL going\n\nLet's start by getting a PostgreSQL container going. I'm going to use version 13.0 (the latest container available) and I'd recommend for this tutorial you do the same. While newer ones might be available, this is the one that will work with this tutorial.\n\n```bash\ndocker run --name my-postgres -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d --rm postgres:13.0\n\ndocker exec -it -u postgres my-postgres psql\n```\n\nWe have to give it a password or PostgreSQL won't start by default. Don't worry, this isn't how'd you start it in production.\n\nAt this point you should\n\n## Databases and Tables\n\nPostgreSQL has the same concept of databases as MongoDB. This will be a group of tables that are related to similar problem-area. It'll be up to you how you choose to group these. Some apps are focused enough to all be in one database; others will need many databases. It's up to you and your data architect to figure out how to do that. In general, things that should be scaled separately (like maybe payment transactions and items in your store?)\n\nTables are similar to collections. This will be a group of records. It's like one Excel spreadsheet. A record is like an object in MongoDB. It's one thing in a table. One record would be a user in the users database.\n\nTables will have a defined schema. Like in Excel, one column will reprent one bit of information, so too will a field in a record represent one bit of information. As opposed to MongoDB, this schema has to be defined in advance and cannot be done on the fly. Altering a table's schema is a hefty operation and on big tables can literally takes hours or days to do. Forethought is a lot more important here.\n\nThis is a simple intro to this. There's a lot more to this but we'll get into as we go through our defined example.\n\n## Our first SQL queries\n\nThe first order of business it create a new database. And we're going to do that using SQL. All SQL is fairly similar but are not necessarily drop-in compatible with each other. So while this would be similar in getting started to MySQL, it wouldn't be identical.\n\nFirst thing you'll notice is I'll capitlize all the key words. This is to make reading the query easier, you can see what's a key word and what's not at a glance. And moreover it's just common to do so I stick with common best practices.\n\nBy default you connect to database \"postgres\" which is just a default database name. Let's make our own called `message_board`.\n\nSo go ahead and run your first query here to create a new database. **Make sure you include the `;` at the end.** While the semi-colon is optional in JS it is not in SQL! It thinks you're still going until you include that `;`.\n\n```sql\nCREATE DATABASE message_boards;\n```\n\nYou should see `CREATE DATABASE` underneath that as a confirmation that it went through. Great! Now we have a new database to switch to, so let's do that.\n\n```sql\n\\c message_boards;\n-- \\connect message_boards works too\n```\n\nThis `\\` notation is how you give admin commands to PostgreSQL through its `psql` CLI which is what we're using right now. In this case we're saying connect to this new database. Let's try a few other commands real quick!\n\n```sql\n-- see all databases\n\\l\n\n-- see all tables in this database, probably won't see anything\n\\d\n\n-- see all available commands\n\\?\n\n-- see available queries\n\\h\n\n-- run a shell command\n\\! ls && echo \"hi from shell!\"\n```\n\nIn case you didn't know, `--` is how you do comments in SQL.\n\n## First table\n\nOkay, so now we have a database and we're connected to it, let's create our first table.\n\n```sql\nCREATE TABLE users (\n  user_id INTEGER PRIMARY KEY GENERATED ALWAYS AS IDENTITY,\n  username VARCHAR ( 25 ) UNIQUE NOT NULL,\n  email VARCHAR ( 50 ) UNIQUE NOT NULL,\n  full_name VARCHAR ( 100 ) NOT NULL,\n  last_login TIMESTAMP,\n  created_on TIMESTAMP NOT NULL\n);\n```\n\nSo let's break this down\n\n- CREATE TABLE is the command we'll use to create a new table. We're naming it the users table\n- `user_id` will be an incrementing field The first users will have a user_if of 1, the second one will have user_id of 2, etc. That's what the `GENERATED ALWAYS AS IDENTITY` means. It's autoincrementing. The PRIMARY KEY part means it's what the table will be indexed on which means inherently that it is indexed.\n- Previously PostgreSQL used a field type called `SERIAL` to describe the serially incrementing IDs. The `GENERATED AS ALWAYS` syntax is newer, more compliant to the generic SQL spec, and works better. Always use it over `SERIAL`.\n- Before, in MongoDB, we relied on the `_id` field to be that key field. PostgreSQL doesn't do that for you by default.\n- We created two VARCHARS which is the SQL way of saying string. The username will have a character limit of 25 and the email will have a charcter limit of 50. Each of them will be guaranteed unique (thanks to UNIQUE) and to not be omitted (thanks to NOT NULL).\n- They could still be empty strings with NOT NULL but you'd have to intentionally specify that.\n- full_name is not unique so you could have two Sally Rogers.\n- We our last_login field it will be the last time the user logged in. We could use this later to clean out inactive accounts. Notice this doesn't have NOT NULL so when we create a new user they can have a null login time because they haven't logged in yet.\n- Lastly we'll provide it with a date via the created_on field so we can keep track of when a user was created.\n\nWe won't be going into too many more PostgreSQL data types but there are a lot. [See here][types].\n\n## First record\n\nLet's insert a user into our new table. This is like adding a new row into a spreadsheet.\n\n```sql\nINSERT INTO users (username, email, full_name, created_on) VALUES ('btholt', 'lol@example.com', 'Brian Holt', NOW());\n```\n\n- This is how you insert a new record into a relational database.\n- The `INSERT INTO` tells the SQL engine you're going to be doing an insert, and we're doing it into `users`.\n- The `()` is where you provide the order you're going to be giving the fields to PostgreSQL in the VALUES part.\n- Notice we're not providing user_id since PostgreSQL will provide that itself.\n- We're also not providing a `last_login` time because it's not required and in theory the user hasn't logged in yet.\n- For the created_on, we're using a special PostgreSQL built in function called `NOW()`. This provide the current time as a parameter in that space.\n\nYou should see `INSERT 0 1` to let you know that the query succeeded. The 1 represents that 1 record was inserted successfully and the 0 represents the OID which we're not covering nor using and will be 0 for us throughout our course i.e. no need to worry about it.\n\n## See your first record\n\nWe're about to get into more advance querying but I want you to see the fruits of your labor! Run this query to fetch every record and every field from a table\n\n```sql\nSELECT * FROM users;\n```\n\nYou should see your one row you've inserted! Good job! You're off to a great start. We'll go over the query we just ran in the next section.\n\n[types]: https://www.postgresql.org/docs/9.5/datatype.html#DATATYPE-TABLE\n","slug":"postgresql","title":"PostgreSQL","section":"Sql","icon":"info-circle","filePath":"/home/runner/work/complete-intro-to-databases-v2/complete-intro-to-databases-v2/lessons/03-sql/B-postgresql.md","nextSlug":"/lessons/sql/querying-postgresql","prevSlug":"/lessons/sql/intro-to-sql-databases"}},"__N_SSG":true}