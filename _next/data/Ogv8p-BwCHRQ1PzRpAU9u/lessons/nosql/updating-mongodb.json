{"pageProps":{"post":{"attributes":{"description":"Brian shows you how to update and delete the documents that have been inserted into the database."},"html":"<h2>insert, insertOne, and insertMany</h2>\n<p>You already encountered insert at the beginning of this section but I just wanted to disambiguate insertOne and insertMany for you. insert essentially does the job of both insertMany and insertOne: if you give it an array it will insert many and if you give it an object it will insert one. The insertOne and insertMany methods are nice because if you accidentally give it the wrong thing (like giving it an object when you meant to give it an array) it will cause an error and make you fix it. With insert, you have a higher chance of it doing the wrong thing.</p>\n<p>In general use insertOne and insertMany. This also applies to delete vs deleteMany/deleteOne, update vs updateMany/updateOne, etc.</p>\n<h2>Updates</h2>\n<p>When you do updates, you&#39;ll have to give a filter as well as what you want to update. Let&#39;s just do an example</p>\n<pre><code class=\"hljs language-javascript\">db.<span class=\"hljs-property\">pets</span>.<span class=\"hljs-title function_\">updateOne</span>(\n  { <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&quot;dog&quot;</span>, <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Luna&quot;</span>, <span class=\"hljs-attr\">breed</span>: <span class=\"hljs-string\">&quot;Havanese&quot;</span> },\n  { <span class=\"hljs-attr\">$set</span>: { <span class=\"hljs-attr\">owner</span>: <span class=\"hljs-string\">&quot;Brian Holt&quot;</span> } }\n);\n</code></pre><p>The first object is the query. This is the same sort of query you&#39;d use in a <code>.find()</code>. The second is your update object. Here you have a few options with the various update operators. Let&#39;s try another one. Let&#39;s say today is <strong>every dog&#39;s</strong> birthday. How could we increase all of their ages with one update?</p>\n<pre><code class=\"hljs language-javascript\">db.<span class=\"hljs-property\">pets</span>.<span class=\"hljs-title function_\">updateMany</span>({ <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&quot;dog&quot;</span> }, { <span class=\"hljs-attr\">$inc</span>: { <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">1</span> } });\n</code></pre><p>This will increase the age of all dogs by 1. There are many more sorts of updates but you can take a look at the docs. <a href=\"https://docs.mongodb.com/manual/reference/operator/update/#id1\">Here are the available update operators</a>.</p>\n<p>Also worth noting there is an extra parameter you can updateOne and updateMany with additional options. We&#39;re about to talk about one of them in the next section, upsert.</p>\n<p>Also do note there is a replaceOne as well. This works just like updateOne but it will delete any fields you omit in your update document that exist already in the doc.</p>\n<h2>upsert</h2>\n<p>MongoDB does have a concept of &quot;upserting&quot;. This is a portmanteau of the words update and insert and means &quot;insert a new document with these things if you don&#39;t find one that exists with that.&quot; Like maybe you want to create a new user with an email address if you haven&#39;t already, and if it does exist you want to update it with new information.</p>\n<p>Let&#39;s see how to do that. Let&#39;s say you want to want to find a dog named &quot;Sudo&quot; and update its owner to &quot;Sarah Drasner&quot; if it exists (it doesn&#39;t in our case) and create a new record with that if there isn&#39;t one.</p>\n<pre><code class=\"hljs language-javascript\">db.<span class=\"hljs-property\">pets</span>.<span class=\"hljs-title function_\">updateOne</span>(\n  {\n    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&quot;dog&quot;</span>,\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Sudo&quot;</span>,\n    <span class=\"hljs-attr\">breed</span>: <span class=\"hljs-string\">&quot;Wheaten&quot;</span>,\n  },\n  {\n    <span class=\"hljs-attr\">$set</span>: {\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&quot;dog&quot;</span>,\n      <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Sudo&quot;</span>,\n      <span class=\"hljs-attr\">breed</span>: <span class=\"hljs-string\">&quot;Wheaten&quot;</span>,\n      <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">5</span>,\n      <span class=\"hljs-attr\">index</span>: <span class=\"hljs-number\">10000</span>,\n      <span class=\"hljs-attr\">owner</span>: <span class=\"hljs-string\">&quot;Sarah Drasner&quot;</span>,\n    },\n  },\n  {\n    <span class=\"hljs-attr\">upsert</span>: <span class=\"hljs-literal\">true</span>,\n  }\n);\n</code></pre><p>We&#39;re playing this a bit fast and lazy. We should really make sure that we&#39;re querying for a unique object based on some sort of a unique key (we&#39;ll get into that next.) But yes, make sure you&#39;re providing a whole document with an upsert, otherwise on the insert side of upsert you&#39;ll get incomplete documents.</p>\n<h2>Deletes</h2>\n<p>Deletes work almost identically to finds except instead of returning documents it deletes them. Both <code>deleteOne</code> and <code>deleteMany</code> exist (as does <code>delete</code> which is discouraged.) Let&#39;s say you wanted to delete all Havanese reptiles because that doesn&#39;t make sense.</p>\n<pre><code class=\"hljs language-javascript\">db.<span class=\"hljs-property\">pets</span>.<span class=\"hljs-title function_\">deleteMany</span>({ <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&quot;reptile&quot;</span>, <span class=\"hljs-attr\">breed</span>: <span class=\"hljs-string\">&quot;Havanese&quot;</span> });\n</code></pre><h2>findAnd*</h2>\n<p>Occasionally you need to find a document <em>and</em> update/delete/replace it at the same time. Instead of having to do two queries and thus have a race-condition of something modifying your document in the interim there are three commands that will allow you to do just that, findOneAndUpdate,\nfindOneAndReplace, and findOneAndDelete. These work basically identically to updateOne, replaceOne, and deleteOne, they just return it at thend.</p>\n<h2>bulkWrite</h2>\n<p>Particularly when you&#39;re writing code, sometimes you need to run a series of queries all at once. That&#39;s probably going to be several inserts or maybe a few updates and deletes. Instead of doing a query, waiting, then serially doing the next one, etc. you can do what&#39;s called a bulkWrite. bulkWrite allows you to queue up an array of queries and it will execute those queries in the order that you provide them to MongoDB. It&#39;s possible but weird to do in the mongo CLI shell so we&#39;ll get into it once we&#39;re doing code. Suffice to say, it&#39;s just what we&#39;ve been doing but instead of one query object, you provide an array of those same query objects.</p>\n","markdown":"\n## insert, insertOne, and insertMany\n\nYou already encountered insert at the beginning of this section but I just wanted to disambiguate insertOne and insertMany for you. insert essentially does the job of both insertMany and insertOne: if you give it an array it will insert many and if you give it an object it will insert one. The insertOne and insertMany methods are nice because if you accidentally give it the wrong thing (like giving it an object when you meant to give it an array) it will cause an error and make you fix it. With insert, you have a higher chance of it doing the wrong thing.\n\nIn general use insertOne and insertMany. This also applies to delete vs deleteMany/deleteOne, update vs updateMany/updateOne, etc.\n\n## Updates\n\nWhen you do updates, you'll have to give a filter as well as what you want to update. Let's just do an example\n\n```javascript\ndb.pets.updateOne(\n  { type: \"dog\", name: \"Luna\", breed: \"Havanese\" },\n  { $set: { owner: \"Brian Holt\" } }\n);\n```\n\nThe first object is the query. This is the same sort of query you'd use in a `.find()`. The second is your update object. Here you have a few options with the various update operators. Let's try another one. Let's say today is **every dog's** birthday. How could we increase all of their ages with one update?\n\n```javascript\ndb.pets.updateMany({ type: \"dog\" }, { $inc: { age: 1 } });\n```\n\nThis will increase the age of all dogs by 1. There are many more sorts of updates but you can take a look at the docs. [Here are the available update operators][update].\n\nAlso worth noting there is an extra parameter you can updateOne and updateMany with additional options. We're about to talk about one of them in the next section, upsert.\n\nAlso do note there is a replaceOne as well. This works just like updateOne but it will delete any fields you omit in your update document that exist already in the doc.\n\n## upsert\n\nMongoDB does have a concept of \"upserting\". This is a portmanteau of the words update and insert and means \"insert a new document with these things if you don't find one that exists with that.\" Like maybe you want to create a new user with an email address if you haven't already, and if it does exist you want to update it with new information.\n\nLet's see how to do that. Let's say you want to want to find a dog named \"Sudo\" and update its owner to \"Sarah Drasner\" if it exists (it doesn't in our case) and create a new record with that if there isn't one.\n\n```javascript\ndb.pets.updateOne(\n  {\n    type: \"dog\",\n    name: \"Sudo\",\n    breed: \"Wheaten\",\n  },\n  {\n    $set: {\n      type: \"dog\",\n      name: \"Sudo\",\n      breed: \"Wheaten\",\n      age: 5,\n      index: 10000,\n      owner: \"Sarah Drasner\",\n    },\n  },\n  {\n    upsert: true,\n  }\n);\n```\n\nWe're playing this a bit fast and lazy. We should really make sure that we're querying for a unique object based on some sort of a unique key (we'll get into that next.) But yes, make sure you're providing a whole document with an upsert, otherwise on the insert side of upsert you'll get incomplete documents.\n\n## Deletes\n\nDeletes work almost identically to finds except instead of returning documents it deletes them. Both `deleteOne` and `deleteMany` exist (as does `delete` which is discouraged.) Let's say you wanted to delete all Havanese reptiles because that doesn't make sense.\n\n```javascript\ndb.pets.deleteMany({ type: \"reptile\", breed: \"Havanese\" });\n```\n\n## findAnd\\*\n\nOccasionally you need to find a document _and_ update/delete/replace it at the same time. Instead of having to do two queries and thus have a race-condition of something modifying your document in the interim there are three commands that will allow you to do just that, findOneAndUpdate,\nfindOneAndReplace, and findOneAndDelete. These work basically identically to updateOne, replaceOne, and deleteOne, they just return it at thend.\n\n## bulkWrite\n\nParticularly when you're writing code, sometimes you need to run a series of queries all at once. That's probably going to be several inserts or maybe a few updates and deletes. Instead of doing a query, waiting, then serially doing the next one, etc. you can do what's called a bulkWrite. bulkWrite allows you to queue up an array of queries and it will execute those queries in the order that you provide them to MongoDB. It's possible but weird to do in the mongo CLI shell so we'll get into it once we're doing code. Suffice to say, it's just what we've been doing but instead of one query object, you provide an array of those same query objects.\n\n[update]: https://docs.mongodb.com/manual/reference/operator/update/#id1\n","slug":"updating-mongodb","title":"Updating Mongodb","section":"Nosql","icon":"info-circle","filePath":"/home/runner/work/complete-intro-to-databases-v2/complete-intro-to-databases-v2/lessons/02-nosql/D-updating-mongodb.md","nextSlug":"/lessons/nosql/indexes-in-mongodb","prevSlug":"/lessons/nosql/querying-mongodb"}},"__N_SSG":true}