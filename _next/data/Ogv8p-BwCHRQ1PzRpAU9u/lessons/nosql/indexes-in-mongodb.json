{"pageProps":{"post":{"attributes":{"description":"When querying against MongoDB, query performance can be very important. Brian shows you how to think about indexing a MongoDB database to improve performance and capabilities."},"html":"<p>Databases are honestly marvels of technology. I remember in my computer science program I had to write one and it could barely run the rudimentary queries it needed to pass the class. These databases are powering everything around you and munging through petabytes of data at scale.</p>\n<p>Frequently these databases can accommodate these queries without any sort of additional configurations; out of the box they&#39;re very fast and flexible. However sometimes you&#39;ll run into some performance issues for various different reasons. The queries will either be very slow, will cause a lot of load on the server running, make the server run unreliably, or even all of the above. In these cases <strong>indexes</strong> can help you. Indexes are a separate data structure that a database maintains so that it can find things quickly. The tradeoff here is that indexes can cause inserts, updates, and deletes to be a bit slower because they also have to update indexes as well as they just take up more room on disk. But in exchange you get very fast queries as well as some other neat properties we&#39;ll explore like enforcing unique keys.</p>\n<h2>Explain</h2>\n<p>Let&#39;s start by saying I&#39;m definitely not an a DBA, a database admin or a database architect depending on who you ask. There are people whose entire jobs are doing things like this: knowing how to optimize databases to fit usecases. Instead, I&#39;m going to walk you through a few use cases and show you the tools I know to probe for better solutions. From there it&#39;s best to work with people who have a deep knowledge of what you&#39;re trying to.</p>\n<p>Consider this fairly simple query:</p>\n<pre><code class=\"hljs language-javascript\">db.<span class=\"hljs-property\">pets</span>.<span class=\"hljs-title function_\">find</span>({ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Fido&quot;</span> });\n</code></pre><p>Pretty simple: find all pets named Fido. However this query does a really dastardly thing: it will actually cause the database to look at <strong>every single record</strong> in the database. For us toying around on our computer this isn&#39;t a big deal but if you&#39;re running this a lot in production this going to be very expensive and fragile. In this case, it&#39;d be much more helpful if there was an index to help us. Let&#39;s first see what explain can tell us.</p>\n<pre><code class=\"hljs language-javascript\">db.<span class=\"hljs-property\">pets</span>.<span class=\"hljs-title function_\">find</span>({ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Fido&quot;</span> }).<span class=\"hljs-title function_\">explain</span>(<span class=\"hljs-string\">&quot;executionStats&quot;</span>);\n</code></pre><p>The two things to notice here are the strategy it used to do our query and how many records it looked at. In this case it looks at <em>every</em> record in our database and it used a <code>COLLSCAN</code> strategy which is the same as a linear search aka O(n) search. Not good! Let&#39;s build an index to make this work a lot better!</p>\n<h2>Create an Index</h2>\n<pre><code class=\"hljs language-javascript\">db.<span class=\"hljs-property\">pets</span>.<span class=\"hljs-title function_\">createIndex</span>({ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-number\">1</span> });\ndb.<span class=\"hljs-property\">pets</span>.<span class=\"hljs-title function_\">find</span>({ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Fido&quot;</span> }).<span class=\"hljs-title function_\">explain</span>(<span class=\"hljs-string\">&quot;executionStats&quot;</span>);\ndb.<span class=\"hljs-property\">pets</span>.<span class=\"hljs-title function_\">find</span>({ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Fido&quot;</span> }).<span class=\"hljs-title function_\">count</span>();\ndb.<span class=\"hljs-property\">pets</span>.<span class=\"hljs-title function_\">getIndexes</span>();\n</code></pre><p>Notice that it went faster. In my case the speedup was about 300%. Then notice that the number of records examined is the same number as the count. Lastly you can always inspect what indexes exist using getIndexes.</p>\n<h2>Compound Indexes</h2>\n<p>If you are frequently using two keys together, like type and breed for example, you could consider using a compound index. This will make an index of those two things together. In the specific case that you are querying with those things together it will perform better than two separate indexes of the two things. Since this isn&#39;t meant to be an in-depth treatise of indexes, I&#39;ll let you explore that when you need it.</p>\n<h2>Unique Indexes</h2>\n<p>Frequently you want to enforce uniqueness on one of the fields in your database. A good example is that an email in your user database should be unique i.e. a user should not be able to sign up twice with the same email address. Our database of pets doesn&#39;t really have a good use case for a unique index but let&#39;s do one on index to show you how to make one. Since <code>_id</code> already exists it&#39;s a redundant to make another number unique index.</p>\n<pre><code class=\"hljs language-javascript\">db.<span class=\"hljs-property\">pets</span>.<span class=\"hljs-title function_\">createIndex</span>({ <span class=\"hljs-attr\">index</span>: <span class=\"hljs-number\">1</span> }, { <span class=\"hljs-attr\">unique</span>: <span class=\"hljs-literal\">true</span> });\n</code></pre><p>If you get an error like the one below, run a deleteOne on the duplicate key to drop one of them and then try again.</p>\n<pre><code class=\"hljs language-json\"><span class=\"hljs-punctuation\">{</span>\n  <span class=\"hljs-attr\">&quot;ok&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-number\">0</span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-attr\">&quot;errmsg&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;Index build failed: 681332bb-c753-45fb-80c2-00ef2ec1a4e7: Collection test.pets ( 2aa18781-33ae-4aa8-846b-934594558b72 ) :: caused by :: E11000 duplicate key error collection: test.pets index: index_1 dup key: { index: 10000.0 }&quot;</span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-attr\">&quot;code&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-number\">11000</span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-attr\">&quot;codeName&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;DuplicateKey&quot;</span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-attr\">&quot;keyPattern&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n    <span class=\"hljs-attr\">&quot;index&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-number\">1</span>\n  <span class=\"hljs-punctuation\">}</span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-attr\">&quot;keyValue&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n    <span class=\"hljs-attr\">&quot;index&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-number\">10000</span>\n  <span class=\"hljs-punctuation\">}</span>\n<span class=\"hljs-punctuation\">}</span>\n</code></pre><p>Once you have it indexed try this query:</p>\n<pre><code class=\"hljs language-javascript\">db.<span class=\"hljs-property\">pets</span>.<span class=\"hljs-title function_\">insertOne</span>({ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Doggo&quot;</span>, <span class=\"hljs-attr\">index</span>: <span class=\"hljs-number\">10</span> });\n</code></pre><p>Now this will fail because 10 already exists. As a bonus, now <code>index</code> is indexed so can easily query by it.</p>\n<pre><code class=\"hljs language-javascript\">db.<span class=\"hljs-property\">pets</span>.<span class=\"hljs-title function_\">find</span>({ <span class=\"hljs-attr\">index</span>: <span class=\"hljs-number\">1337</span> }).<span class=\"hljs-title function_\">explain</span>(<span class=\"hljs-string\">&quot;executionStats&quot;</span>);\n</code></pre><p>Notice it only looks at one record!</p>\n<h2>Text Index</h2>\n<p>Frequently something you want to do is called &quot;full text search.&quot; This is the similar to what happens you search Google for something: you want it to drop &quot;stop words&quot; (things like a, the, and, etc.) and you want it to fuzzy match things. Like if I was searching for &quot;Luna Havanese dog&quot; I&#39;d expect to match all dogs named Luna that are Havanese.</p>\n<p>First of all, this is directly possible in MongoDB (it used to not be.) However there is entire style of database that does this for you, called search engines. <a href=\"https://lucene.apache.org/solr/\">Apache Solr</a> is the one I used to use at my old job. There are tradeoffs and things that a full separate server can do for you that MongoDB can&#39;t. And you can scale them separately which can be helpful.</p>\n<p>So in MongoDB you&#39;ll create a text index. Each collection can only have one text index so make sure you&#39;re indexing all the fields you want to in the one you choose. In our case let&#39;s index type, breed, and name.</p>\n<p>Also bears mentioning that by default it does text search in English. It&#39;s possible to set it to other languages or no language at all. <a href=\"https://docs.mongodb.com/manual/tutorial/specify-language-for-text-index/\">See here</a>.</p>\n<pre><code class=\"hljs language-javascript\">db.<span class=\"hljs-property\">pets</span>.<span class=\"hljs-title function_\">createIndex</span>({\n  <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&quot;text&quot;</span>,\n  <span class=\"hljs-attr\">breed</span>: <span class=\"hljs-string\">&quot;text&quot;</span>,\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;text&quot;</span>,\n});\n</code></pre><p>Okay, so now we&#39;ve indexed it, how do we search it? You&#39;ll use a special $text operator.</p>\n<pre><code class=\"hljs language-javascript\">db.<span class=\"hljs-property\">pets</span>.<span class=\"hljs-title function_\">find</span>({ <span class=\"hljs-attr\">$text</span>: { <span class=\"hljs-attr\">$search</span>: <span class=\"hljs-string\">&quot;dog Havanese Luna&quot;</span> } });\n</code></pre><p>Okay, so notice this is doing an &quot;any&quot; match and not sorting on the most accurate score. Frequently this isn&#39;t what you want: you want the thing that matches most closely with your search terms. We can do that, it just doesn&#39;t do that by default.</p>\n<pre><code class=\"hljs language-javascript\">db.<span class=\"hljs-property\">pets</span>\n  .<span class=\"hljs-title function_\">find</span>({ <span class=\"hljs-attr\">$text</span>: { <span class=\"hljs-attr\">$search</span>: <span class=\"hljs-string\">&quot;dog Havanese Luna&quot;</span> } })\n  .<span class=\"hljs-title function_\">sort</span>({ <span class=\"hljs-attr\">score</span>: { <span class=\"hljs-attr\">$meta</span>: <span class=\"hljs-string\">&quot;textScore&quot;</span> } });\n</code></pre><p>This will now send you back the ones that most closely resemble what you&#39;re looking for. If you want to see the actual text scores, here&#39;s how you can see them.</p>\n<pre><code class=\"hljs language-javascript\">db.<span class=\"hljs-property\">pets</span>\n  .<span class=\"hljs-title function_\">find</span>(\n    { <span class=\"hljs-attr\">$text</span>: { <span class=\"hljs-attr\">$search</span>: <span class=\"hljs-string\">&quot;dog Havanese Luna&quot;</span> } },\n    { <span class=\"hljs-attr\">score</span>: { <span class=\"hljs-attr\">$meta</span>: <span class=\"hljs-string\">&quot;textScore&quot;</span> } }\n  )\n  .<span class=\"hljs-title function_\">sort</span>({ <span class=\"hljs-attr\">score</span>: { <span class=\"hljs-attr\">$meta</span>: <span class=\"hljs-string\">&quot;textScore&quot;</span> } });\n</code></pre><p>One more note, the <code>&quot;&quot;</code> and <code>-</code> operators from Google do work here. If you want to search for all Lunas that are not cats you can do this:</p>\n<pre><code class=\"hljs language-javascript\">db.<span class=\"hljs-property\">pets</span>\n  .<span class=\"hljs-title function_\">find</span>({ <span class=\"hljs-attr\">$text</span>: { <span class=\"hljs-attr\">$search</span>: <span class=\"hljs-string\">&quot;-cat Luna&quot;</span> } })\n  .<span class=\"hljs-title function_\">sort</span>({ <span class=\"hljs-attr\">score</span>: { <span class=\"hljs-attr\">$meta</span>: <span class=\"hljs-string\">&quot;textScore&quot;</span> } });\n</code></pre><p>There&#39;s more to the $text search operator which I&#39;ll leave you to explore. <a href=\"https://docs.mongodb.com/manual/reference/operator/query/text/index.html\">See here</a>.</p>\n","markdown":"\nDatabases are honestly marvels of technology. I remember in my computer science program I had to write one and it could barely run the rudimentary queries it needed to pass the class. These databases are powering everything around you and munging through petabytes of data at scale.\n\nFrequently these databases can accommodate these queries without any sort of additional configurations; out of the box they're very fast and flexible. However sometimes you'll run into some performance issues for various different reasons. The queries will either be very slow, will cause a lot of load on the server running, make the server run unreliably, or even all of the above. In these cases **indexes** can help you. Indexes are a separate data structure that a database maintains so that it can find things quickly. The tradeoff here is that indexes can cause inserts, updates, and deletes to be a bit slower because they also have to update indexes as well as they just take up more room on disk. But in exchange you get very fast queries as well as some other neat properties we'll explore like enforcing unique keys.\n\n## Explain\n\nLet's start by saying I'm definitely not an a DBA, a database admin or a database architect depending on who you ask. There are people whose entire jobs are doing things like this: knowing how to optimize databases to fit usecases. Instead, I'm going to walk you through a few use cases and show you the tools I know to probe for better solutions. From there it's best to work with people who have a deep knowledge of what you're trying to.\n\nConsider this fairly simple query:\n\n```javascript\ndb.pets.find({ name: \"Fido\" });\n```\n\nPretty simple: find all pets named Fido. However this query does a really dastardly thing: it will actually cause the database to look at **every single record** in the database. For us toying around on our computer this isn't a big deal but if you're running this a lot in production this going to be very expensive and fragile. In this case, it'd be much more helpful if there was an index to help us. Let's first see what explain can tell us.\n\n```javascript\ndb.pets.find({ name: \"Fido\" }).explain(\"executionStats\");\n```\n\nThe two things to notice here are the strategy it used to do our query and how many records it looked at. In this case it looks at _every_ record in our database and it used a `COLLSCAN` strategy which is the same as a linear search aka O(n) search. Not good! Let's build an index to make this work a lot better!\n\n## Create an Index\n\n```javascript\ndb.pets.createIndex({ name: 1 });\ndb.pets.find({ name: \"Fido\" }).explain(\"executionStats\");\ndb.pets.find({ name: \"Fido\" }).count();\ndb.pets.getIndexes();\n```\n\nNotice that it went faster. In my case the speedup was about 300%. Then notice that the number of records examined is the same number as the count. Lastly you can always inspect what indexes exist using getIndexes.\n\n## Compound Indexes\n\nIf you are frequently using two keys together, like type and breed for example, you could consider using a compound index. This will make an index of those two things together. In the specific case that you are querying with those things together it will perform better than two separate indexes of the two things. Since this isn't meant to be an in-depth treatise of indexes, I'll let you explore that when you need it.\n\n## Unique Indexes\n\nFrequently you want to enforce uniqueness on one of the fields in your database. A good example is that an email in your user database should be unique i.e. a user should not be able to sign up twice with the same email address. Our database of pets doesn't really have a good use case for a unique index but let's do one on index to show you how to make one. Since `_id` already exists it's a redundant to make another number unique index.\n\n```javascript\ndb.pets.createIndex({ index: 1 }, { unique: true });\n```\n\nIf you get an error like the one below, run a deleteOne on the duplicate key to drop one of them and then try again.\n\n```json\n{\n  \"ok\": 0,\n  \"errmsg\": \"Index build failed: 681332bb-c753-45fb-80c2-00ef2ec1a4e7: Collection test.pets ( 2aa18781-33ae-4aa8-846b-934594558b72 ) :: caused by :: E11000 duplicate key error collection: test.pets index: index_1 dup key: { index: 10000.0 }\",\n  \"code\": 11000,\n  \"codeName\": \"DuplicateKey\",\n  \"keyPattern\": {\n    \"index\": 1\n  },\n  \"keyValue\": {\n    \"index\": 10000\n  }\n}\n```\n\nOnce you have it indexed try this query:\n\n```javascript\ndb.pets.insertOne({ name: \"Doggo\", index: 10 });\n```\n\nNow this will fail because 10 already exists. As a bonus, now `index` is indexed so can easily query by it.\n\n```javascript\ndb.pets.find({ index: 1337 }).explain(\"executionStats\");\n```\n\nNotice it only looks at one record!\n\n## Text Index\n\nFrequently something you want to do is called \"full text search.\" This is the similar to what happens you search Google for something: you want it to drop \"stop words\" (things like a, the, and, etc.) and you want it to fuzzy match things. Like if I was searching for \"Luna Havanese dog\" I'd expect to match all dogs named Luna that are Havanese.\n\nFirst of all, this is directly possible in MongoDB (it used to not be.) However there is entire style of database that does this for you, called search engines. [Apache Solr][solr] is the one I used to use at my old job. There are tradeoffs and things that a full separate server can do for you that MongoDB can't. And you can scale them separately which can be helpful.\n\nSo in MongoDB you'll create a text index. Each collection can only have one text index so make sure you're indexing all the fields you want to in the one you choose. In our case let's index type, breed, and name.\n\nAlso bears mentioning that by default it does text search in English. It's possible to set it to other languages or no language at all. [See here][text-index].\n\n```javascript\ndb.pets.createIndex({\n  type: \"text\",\n  breed: \"text\",\n  name: \"text\",\n});\n```\n\nOkay, so now we've indexed it, how do we search it? You'll use a special \\$text operator.\n\n```javascript\ndb.pets.find({ $text: { $search: \"dog Havanese Luna\" } });\n```\n\nOkay, so notice this is doing an \"any\" match and not sorting on the most accurate score. Frequently this isn't what you want: you want the thing that matches most closely with your search terms. We can do that, it just doesn't do that by default.\n\n```javascript\ndb.pets\n  .find({ $text: { $search: \"dog Havanese Luna\" } })\n  .sort({ score: { $meta: \"textScore\" } });\n```\n\nThis will now send you back the ones that most closely resemble what you're looking for. If you want to see the actual text scores, here's how you can see them.\n\n```javascript\ndb.pets\n  .find(\n    { $text: { $search: \"dog Havanese Luna\" } },\n    { score: { $meta: \"textScore\" } }\n  )\n  .sort({ score: { $meta: \"textScore\" } });\n```\n\nOne more note, the `\"\"` and `-` operators from Google do work here. If you want to search for all Lunas that are not cats you can do this:\n\n```javascript\ndb.pets\n  .find({ $text: { $search: \"-cat Luna\" } })\n  .sort({ score: { $meta: \"textScore\" } });\n```\n\nThere's more to the \\$text search operator which I'll leave you to explore. [See here][text].\n\n[solr]: https://lucene.apache.org/solr/\n[text-index]: https://docs.mongodb.com/manual/tutorial/specify-language-for-text-index/\n[text]: https://docs.mongodb.com/manual/reference/operator/query/text/index.html\n","slug":"indexes-in-mongodb","title":"Indexes in Mongodb","section":"Nosql","icon":"info-circle","filePath":"/home/runner/work/complete-intro-to-databases-v2/complete-intro-to-databases-v2/lessons/02-nosql/E-indexes-in-mongodb.md","nextSlug":"/lessons/nosql/aggregation","prevSlug":"/lessons/nosql/updating-mongodb"}},"__N_SSG":true}