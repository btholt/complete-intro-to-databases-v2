{"pageProps":{"post":{"attributes":{"description":""},"html":"<p>MongoDB has a fun feature called aggregation. There&#39;s two ways of doing it, aggregation pipelines and map-reduce. Map-reduce is exactly what you&#39;d expect if you&#39;re from a functional programming background: you provide MongoDB a map function that it will run every item in the array and then a reduce function to aggregate your collection into a smaller set of data.</p>\n<p>MongoDB also released a newer feature of aggregation pipelines that tend to perform better and can also be easier to maintain. With these you provide a configuration object to the <code>aggregation</code> pipeline</p>\n<p>What if we wanted to know how many puppies, adult, and senior dogs we have in our pets collection? Let&#39;s try just that</p>\n<pre><code class=\"hljs language-javascript\">db.<span class=\"hljs-property\">pets</span>.<span class=\"hljs-title function_\">aggregate</span>([\n  {\n    <span class=\"hljs-attr\">$bucket</span>: {\n      <span class=\"hljs-attr\">groupBy</span>: <span class=\"hljs-string\">&quot;$age&quot;</span>,\n      <span class=\"hljs-attr\">boundaries</span>: [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">15</span>],\n      <span class=\"hljs-attr\">default</span>: <span class=\"hljs-string\">&quot;very senior&quot;</span>,\n      <span class=\"hljs-attr\">output</span>: {\n        <span class=\"hljs-attr\">count</span>: { <span class=\"hljs-attr\">$sum</span>: <span class=\"hljs-number\">1</span> },\n      },\n    },\n  },\n]);\n</code></pre><ul>\n<li>With the aggregation pipelines, you provide a step of things to do. In this case we only have one step, bucket pets into 0-2 years old, 3-8 years old, 9-15 years, and &quot;very senior&quot; (which is the default bucket.)</li>\n<li>With the output you&#39;re defining what you want to pass to the next step. In this case we just want to sum them up by adding 1 to the count each time we see a pet that matches a bucket.</li>\n</ul>\n<p>This is all pets. We want just dogs. Let&#39;s add another stage.</p>\n<pre><code class=\"hljs language-javascript\">db.<span class=\"hljs-property\">pets</span>.<span class=\"hljs-title function_\">aggregate</span>([\n  {\n    <span class=\"hljs-attr\">$match</span>: {\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&quot;dog&quot;</span>,\n    },\n  },\n  {\n    <span class=\"hljs-attr\">$bucket</span>: {\n      <span class=\"hljs-attr\">groupBy</span>: <span class=\"hljs-string\">&quot;$age&quot;</span>,\n      <span class=\"hljs-attr\">boundaries</span>: [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">15</span>],\n      <span class=\"hljs-attr\">default</span>: <span class=\"hljs-string\">&quot;very senior&quot;</span>,\n      <span class=\"hljs-attr\">output</span>: {\n        <span class=\"hljs-attr\">count</span>: { <span class=\"hljs-attr\">$sum</span>: <span class=\"hljs-number\">1</span> },\n      },\n    },\n  },\n]);\n</code></pre><p>Using the <code>$match</code> stage of the aggregation, we can exclude every pet that isn&#39;t a dog.</p>\n<p>Last one, what if we wanted to sort the results by which group had the most pets?</p>\n<pre><code class=\"hljs language-javascript\">db.<span class=\"hljs-property\">pets</span>.<span class=\"hljs-title function_\">aggregate</span>([\n  {\n    <span class=\"hljs-attr\">$match</span>: {\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&quot;dog&quot;</span>,\n    },\n  },\n  {\n    <span class=\"hljs-attr\">$bucket</span>: {\n      <span class=\"hljs-attr\">groupBy</span>: <span class=\"hljs-string\">&quot;$age&quot;</span>,\n      <span class=\"hljs-attr\">boundaries</span>: [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">15</span>],\n      <span class=\"hljs-attr\">default</span>: <span class=\"hljs-string\">&quot;very senior&quot;</span>,\n      <span class=\"hljs-attr\">output</span>: {\n        <span class=\"hljs-attr\">count</span>: { <span class=\"hljs-attr\">$sum</span>: <span class=\"hljs-number\">1</span> },\n      },\n    },\n  },\n  {\n    <span class=\"hljs-attr\">$sort</span>: {\n      <span class=\"hljs-attr\">count</span>: -<span class=\"hljs-number\">1</span>,\n    },\n  },\n]);\n</code></pre><p>As you can see, you just add more stages to the aggregation until you gather the insights you&#39;re looking for. There are many more things you can do, so <a href=\"https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/\">here&#39;s a link to all the existing aggregation stages</a>.</p>\n<p>This is definitely one of the most fun parts about MongoDB. We used to use MongoDB&#39;s aggregation features to catch fraudsters in our classifieds app!</p>\n","markdown":"\nMongoDB has a fun feature called aggregation. There's two ways of doing it, aggregation pipelines and map-reduce. Map-reduce is exactly what you'd expect if you're from a functional programming background: you provide MongoDB a map function that it will run every item in the array and then a reduce function to aggregate your collection into a smaller set of data.\n\nMongoDB also released a newer feature of aggregation pipelines that tend to perform better and can also be easier to maintain. With these you provide a configuration object to the `aggregation` pipeline\n\nWhat if we wanted to know how many puppies, adult, and senior dogs we have in our pets collection? Let's try just that\n\n```javascript\ndb.pets.aggregate([\n  {\n    $bucket: {\n      groupBy: \"$age\",\n      boundaries: [0, 3, 9, 15],\n      default: \"very senior\",\n      output: {\n        count: { $sum: 1 },\n      },\n    },\n  },\n]);\n```\n\n- With the aggregation pipelines, you provide a step of things to do. In this case we only have one step, bucket pets into 0-2 years old, 3-8 years old, 9-15 years, and \"very senior\" (which is the default bucket.)\n- With the output you're defining what you want to pass to the next step. In this case we just want to sum them up by adding 1 to the count each time we see a pet that matches a bucket.\n\nThis is all pets. We want just dogs. Let's add another stage.\n\n```javascript\ndb.pets.aggregate([\n  {\n    $match: {\n      type: \"dog\",\n    },\n  },\n  {\n    $bucket: {\n      groupBy: \"$age\",\n      boundaries: [0, 3, 9, 15],\n      default: \"very senior\",\n      output: {\n        count: { $sum: 1 },\n      },\n    },\n  },\n]);\n```\n\nUsing the `$match` stage of the aggregation, we can exclude every pet that isn't a dog.\n\nLast one, what if we wanted to sort the results by which group had the most pets?\n\n```javascript\ndb.pets.aggregate([\n  {\n    $match: {\n      type: \"dog\",\n    },\n  },\n  {\n    $bucket: {\n      groupBy: \"$age\",\n      boundaries: [0, 3, 9, 15],\n      default: \"very senior\",\n      output: {\n        count: { $sum: 1 },\n      },\n    },\n  },\n  {\n    $sort: {\n      count: -1,\n    },\n  },\n]);\n```\n\nAs you can see, you just add more stages to the aggregation until you gather the insights you're looking for. There are many more things you can do, so [here's a link to all the existing aggregation stages][stages].\n\nThis is definitely one of the most fun parts about MongoDB. We used to use MongoDB's aggregation features to catch fraudsters in our classifieds app!\n\n[stages]: https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/\n","slug":"aggregation","title":"Aggregation","section":"Nosql","icon":"info-circle","filePath":"/home/runner/work/complete-intro-to-databases-v2/complete-intro-to-databases-v2/lessons/02-nosql/F-aggregation.md","nextSlug":"/lessons/nosql/nodejs-app-with-mongodb","prevSlug":"/lessons/nosql/indexes-in-mongodb"}},"__N_SSG":true}