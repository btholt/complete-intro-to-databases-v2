<!DOCTYPE html><html><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width" data-next-head=""/><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png" data-next-head=""/><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png" data-next-head=""/><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png" data-next-head=""/><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png" data-next-head=""/><link rel="icon" type="image/x-icon" href="/images/favicon.ico" data-next-head=""/><title data-next-head="">JSON in PostgreSQL – Complete Intro to Databases v2</title><meta name="description" content="One of PostgreSQL&#x27;s super powers is that it&#x27;s able to store and query JSON" data-next-head=""/><meta name="keywords" content="postgres,sql,redis,mongodb,neo4j,database,data,agents" data-next-head=""/><meta name="og:description" content="One of PostgreSQL&#x27;s super powers is that it&#x27;s able to store and query JSON" data-next-head=""/><meta name="og:title" content="JSON in PostgreSQL – Complete Intro to Databases v2" data-next-head=""/><meta name="og:image" content="/images/social-share-cover.jpg" data-next-head=""/><meta name="twitter:card" content="summary_large_image" data-next-head=""/><link data-next-font="size-adjust" rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/_next/static/chunks/3802a39ca373f962.css" as="style"/><link rel="stylesheet" href="/_next/static/chunks/3802a39ca373f962.css" data-n-g=""/><noscript data-n-css=""></noscript><script src="/_next/static/chunks/dbe15a90055bd265.js" defer=""></script><script src="/_next/static/chunks/49c75c2ed6206f46.js" defer=""></script><script src="/_next/static/chunks/da0ff8adaa6cce90.js" defer=""></script><script src="/_next/static/chunks/turbopack-342361b32f83e6b6.js" defer=""></script><script src="/_next/static/chunks/f189af6b04c7fd39.js" defer=""></script><script src="/_next/static/chunks/turbopack-8b35dea75ba6f85c.js" defer=""></script><script src="/_next/static/Ogv8p-BwCHRQ1PzRpAU9u/_ssgManifest.js" defer=""></script><script src="/_next/static/Ogv8p-BwCHRQ1PzRpAU9u/_buildManifest.js" defer=""></script></head><body><script async="" defer="" src="https://a.holt.courses/latest.js"></script><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"/><div id="__next"><link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&amp;display=swap" rel="stylesheet"/><div class="remix-app"><header class="navbar"><h1 class="navbar-brand"><a href="/">Complete Intro to Databases v2</a></h1><div class="navbar-info"><a href="https://frontendmasters.com/workshops/databases-v2/" class="cta-btn">Watch on Frontend Masters</a></div></header><div class="content-container"><div class="main"><div class="lesson-container"><div class="lesson"><div class="lesson-content"><h2>Error in this course</h2>
<p>This course incorrectly chooses to use the <code>JSON</code> data type when it should have used the <code>JSONB</code> data type. Everything in this course will work with either one but when you&#39;re creating your own database you almost always (let&#39;s just say always) want to choose JSONB because it stores the data in a more queryable format and more optimized for querying whereas JSON is a glorified text field. So feel free to use <code>JSONB</code> everywhere where it says <code>JSON</code> or you can just use <code>JSON</code> knowing that when you go do it for yourself you&#39;re going to use <code>JSONB</code>. I&#39;ve correct the references in this doc from JSON to JSONB but the videos will still says JSON.</p>
<p><a href="https://www.citusdata.com/blog/2016/07/14/choosing-nosql-hstore-json-jsonb/">For more info read this blog post about it</a>.</p>
<h2>JSON</h2>
<p>Sometimes you have data that just doesn&#39;t have a nice schema to it. If you tried to fit it into a table database like PostgreSQL, you would end having very generic field names that would have to be interprepted by code or you&#39;d end up with multiple tables to be able describe different schemas. This is one place where document based databases like MongoDB really shine; their schemaless database works really well in these situations.</p>
<p>However PostgreSQL has a magic superpower here: the JSONB data type. This allows you to put JSONB objects into a column and then you can use SQL to query those objects.</p>
<p>Let&#39;s make an example for our message board. You want to add a new feature that allows users to do rich content embeds in your message board. For starters they&#39;ll be able to embed polls, images, and videos but you can imagine growing that in the future so they can embed tweets, documents, and other things we haven&#39;t dreamed up yet. You want to maintain that future flexibility.</p>
<p>This would be possible to model with a normal schema but it&#39;d come out pretty ugly and hard to understand, and it&#39;s impossible to anticipate all our future growth plans now. This is where the <code>JSONB</code> data type is going to really shine. These are the queries we ran to create them. (you don&#39;t need to run them again)</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> rich_content;

<span class="hljs-keyword">CREATE TABLE</span> rich_content (
  content_id <span class="hljs-type">INTEGER</span> <span class="hljs-keyword">PRIMARY KEY</span> GENERATED ALWAYS <span class="hljs-keyword">AS</span> <span class="hljs-keyword">IDENTITY</span>,
  comment_id <span class="hljs-type">INT</span> <span class="hljs-keyword">REFERENCES</span> comments(comment_id) <span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> CASCADE,
  content JSONB <span class="hljs-keyword">NOT NULL</span>
);

<span class="hljs-keyword">INSERT INTO</span> rich_content
  (comment_id, content)
<span class="hljs-keyword">VALUES</span>
  (<span class="hljs-number">63</span>, <span class="hljs-string">&#x27;{ &quot;type&quot;: &quot;poll&quot;, &quot;question&quot;: &quot;What is your favorite color?&quot;, &quot;options&quot;: [&quot;blue&quot;, &quot;red&quot;, &quot;green&quot;, &quot;yellow&quot;] }&#x27;</span>),
  (<span class="hljs-number">358</span>, <span class="hljs-string">&#x27;{ &quot;type&quot;: &quot;video&quot;, &quot;url&quot;: &quot;https://youtu.be/dQw4w9WgXcQ&quot;, &quot;dimensions&quot;: { &quot;height&quot;: 1080, &quot;width&quot;: 1920 }}&#x27;</span>),
  (<span class="hljs-number">358</span>, <span class="hljs-string">&#x27;{ &quot;type&quot;: &quot;poll&quot;, &quot;question&quot;: &quot;Is this your favorite video?&quot;, &quot;options&quot;: [&quot;yes&quot;, &quot;no&quot;, &quot;oh you&quot;] }&#x27;</span>),
  (<span class="hljs-number">410</span>, <span class="hljs-string">&#x27;{ &quot;type&quot;: &quot;image&quot;, &quot;url&quot;: &quot;https://btholt.github.io/complete-intro-to-linux-and-the-cli/WORDMARK-Small.png&quot;, &quot;dimensions&quot;: { &quot;height&quot;: 400, &quot;width&quot;: 1084 }}&#x27;</span>),
  (<span class="hljs-number">485</span>, <span class="hljs-string">&#x27;{ &quot;type&quot;: &quot;image&quot;, &quot;url&quot;: &quot;https://btholt.github.io/complete-intro-to-linux-and-the-cli/HEADER.png&quot;, &quot;dimensions&quot;: { &quot;height&quot;: 237 , &quot;width&quot;: 3301 }}&#x27;</span>);
</code></pre><ul>
<li>The <code>JSONB</code> data type is the shining star here. This allows us to insert JSON objects to be queried later.</li>
<li>PostgreSQL won&#39;t let you insert malformatted JSON so it does validate it for you.</li>
<li>Notice you can have as much nesting as you want. Any valid JSON is valid here.</li>
</ul>
<p>So let&#39;s do some querying! We&#39;re going to use two new symbols, <code>-&gt;</code> and <code>-&gt;&gt;</code>. The <code>-&gt;</code> means &quot;give me back the JSON object&quot;. The return type will be a JSON object, even if it&#39;s just a string. It&#39;s basically a black box to PostgreSQL and it treats all JSON the same, whether it&#39;s an array, object, or just a string. The <code>-&gt;&gt;</code> means &quot;give me this back as a string.&quot;</p>
<p>Find the all the different types of rich content.</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> content <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;type&#x27;</span> <span class="hljs-keyword">FROM</span> rich_content;
</code></pre><p>You&#39;ll get something like this</p>
<pre><code class="hljs language-md"><span class="hljs-section">## ?column?</span>

&quot;poll&quot;
&quot;video&quot;
&quot;poll&quot;
&quot;image&quot;
&quot;image&quot;
</code></pre><p>It repeats poll and image twice because there&#39;s two of those. What if we just wanted the distinct options and no repeats? GROUP BY would work but let&#39;s detour to talk about <code>SELECT DISTINCT</code>. SELECT DISTINCT will deduplicate your results for you. Try this (this will error)</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> content <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;type&#x27;</span> <span class="hljs-keyword">FROM</span> rich_content;
</code></pre><p>PostgreSQL doesn&#39;t actually know what data type it&#39;s going to get back from JSON so it refuses to do any sort of comparisons with the results. We have to tell PostgreSQL &quot;this is definitely going to be text.</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> <span class="hljs-built_in">CAST</span>(content <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;type&#x27;</span> <span class="hljs-keyword">AS</span> TEXT) <span class="hljs-keyword">FROM</span> rich_content;
</code></pre><p>However this is a ton easier if you just <code>-&gt;&gt;</code></p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> content <span class="hljs-operator">-</span><span class="hljs-operator">&gt;&gt;</span> <span class="hljs-string">&#x27;type&#x27;</span> <span class="hljs-keyword">FROM</span> rich_content;
</code></pre><p>That&#39;s the key difference between <code>-&gt;</code> and <code>-&gt;&gt;</code>.</p>
<p>What if we wanted to only query for polls?</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> content <span class="hljs-operator">-</span><span class="hljs-operator">&gt;&gt;</span> <span class="hljs-string">&#x27;type&#x27;</span> <span class="hljs-keyword">AS</span> content_type, comment_id <span class="hljs-keyword">FROM</span> rich_content <span class="hljs-keyword">WHERE</span> content <span class="hljs-operator">-</span><span class="hljs-operator">&gt;&gt;</span> <span class="hljs-string">&#x27;type&#x27;</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;poll&#x27;</span>;
</code></pre><p>Unfortunately due to the execution order (WHERE happens before SELECT) you can&#39;t reference content_type and have to give it the full expression.</p>
<p>Okay, last one. What if we wanted to find all the widths and heights?</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span>
  content <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;dimensions&#x27;</span> <span class="hljs-operator">-</span><span class="hljs-operator">&gt;&gt;</span> <span class="hljs-string">&#x27;height&#x27;</span> <span class="hljs-keyword">AS</span> height,
  content <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;dimensions&#x27;</span> <span class="hljs-operator">-</span><span class="hljs-operator">&gt;&gt;</span> <span class="hljs-string">&#x27;width&#x27;</span> <span class="hljs-keyword">AS</span> width,
  comment_id
<span class="hljs-keyword">FROM</span>
  rich_content;
</code></pre><p>You can use the <code>-&gt;</code> and <code>-&gt;&gt;</code> multiple times to look at nested values. This will give you back the ones that don&#39;t have heights and widths too. To filter those out just do:</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span>
  content <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;dimensions&#x27;</span> <span class="hljs-operator">-</span><span class="hljs-operator">&gt;&gt;</span> <span class="hljs-string">&#x27;height&#x27;</span> <span class="hljs-keyword">AS</span> height,
  content <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;dimensions&#x27;</span> <span class="hljs-operator">-</span><span class="hljs-operator">&gt;&gt;</span> <span class="hljs-string">&#x27;width&#x27;</span> <span class="hljs-keyword">AS</span> width,
  comment_id
<span class="hljs-keyword">FROM</span>
  rich_content
<span class="hljs-keyword">WHERE</span>
  content <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;dimensions&#x27;</span> <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT NULL</span>;
</code></pre></div><div class="lesson-links"><a class="prev" href="/lessons/sql/complex-sql-queries">← Previous</a><a class="next" href="/lessons/sql/indexes-in-postgresql">Next →</a></div></div><div class="details-bg"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="154" height="154" viewBox="0 0 154 154"><defs><clipPath id="clip-path"><rect id="Rectangle_2238" data-name="Rectangle 2238" width="154" height="154" transform="translate(9467 350)" fill="#fff" stroke="#707070" stroke-width="1"></rect></clipPath><clipPath id="clip-corner-image-active"><rect width="154" height="154"></rect></clipPath></defs><g id="corner-image-active" clip-path="url(#clip-corner-image-active)"><g id="Corner-image-active-2" data-name="Corner-image-active" transform="translate(-9467 -350)" clip-path="url(#clip-path)"><path id="Subtraction_34" data-name="Subtraction 34" d="M-3857.365,1740.766h0l-7.07-7.07,12.89-12.89v14.142l-5.818,5.818Zm-14.142-14.142h0l-7.071-7.07,27.033-27.033v14.143l-19.96,19.96Zm-14.143-14.143h0l-7.07-7.069,41.175-41.175v14.142Zm-14.142-14.142h0l-7.07-7.069,55.317-55.317v14.142Zm-14.142-14.142h0l-7.07-7.069,69.459-69.459v14.142Zm-14.142-14.142h0l-7.07-7.069,76.739-76.739h6.862v7.28Zm-14.143-14.143h0l-7.07-7.069,62.6-62.6h14.142Zm-14.142-14.142h0l-7.07-7.069,48.454-48.454h14.142Zm-14.142-14.142h0l-7.07-7.069,34.312-34.312h14.142Zm-14.142-14.142h0l-7.07-7.069,20.17-20.17h14.142Zm-14.142-14.142h0l-7.071-7.071,6.027-6.027h14.144l-13.1,13.1Zm367.24-56.114v-.909l.455.455-.453.453Z" transform="translate(13472.546 -1236.766)" fill="var(--corner-fill)"></path></g></g></svg></div></div></div></div><footer class="footer"><ul class="socials"><li class="social"><a href="https://twitter.com/holtbt"><svg fill="none" height="100%" width="32" xmlns="http://www.w3.org/2000/svg" viewBox="0.254 0.25 500 451.95400000000006"><path d="M394.033.25h76.67L303.202 191.693l197.052 260.511h-154.29L225.118 294.205 86.844 452.204H10.127l179.16-204.77L.254.25H158.46l109.234 144.417zm-26.908 406.063h42.483L135.377 43.73h-45.59z" fill="var(--footer-icons)"></path></svg></a></li><li class="social"><a href="https://bsky.app/profile/brianholt.me"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 -3.268 64 68.414" width="38" height="100%"><path fill="var(--footer-icons)" d="M13.873 3.805C21.21 9.332 29.103 20.537 32 26.55v15.882c0-.338-.13.044-.41.867-1.512 4.456-7.418 21.847-20.923 7.944-7.111-7.32-3.819-14.64 9.125-16.85-7.405 1.264-15.73-.825-18.014-9.015C1.12 23.022 0 8.51 0 6.55 0-3.268 8.579-.182 13.873 3.805zm36.254 0C42.79 9.332 34.897 20.537 32 26.55v15.882c0-.338.13.044.41.867 1.512 4.456 7.418 21.847 20.923 7.944 7.111-7.32 3.819-14.64-9.125-16.85 7.405 1.264 15.73-.825 18.014-9.015C62.88 23.022 64 8.51 64 6.55c0-9.818-8.578-6.732-13.873-2.745z"></path></svg></a></li><li class="social"><a href="https://github.com/btholt"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="32" height="32" viewBox="0 0 32 32"><defs><clipPath id="clip-github-social"><rect width="32" height="32"></rect></clipPath></defs><g id="github-social" clip-path="url(#clip-github-social)"><g id="Group_272" data-name="Group 272" transform="translate(13522.5 -6994)"><path id="Subtraction_33" data-name="Subtraction 33" d="M-24967.5,8041a15.9,15.9,0,0,1-11.312-4.688A15.893,15.893,0,0,1-24983.5,8025a15.893,15.893,0,0,1,4.689-11.315A15.894,15.894,0,0,1-24967.5,8009a15.894,15.894,0,0,1,11.313,4.686A15.893,15.893,0,0,1-24951.5,8025a15.893,15.893,0,0,1-4.689,11.313A15.9,15.9,0,0,1-24967.5,8041Zm-3.781-4.571h0v3.918h7.895v-6.665a1.836,1.836,0,0,0-1.2-1.718c5.1-.617,7.467-2.975,7.467-7.424a7.176,7.176,0,0,0-1.637-4.728,6.74,6.74,0,0,0,.275-1.812,4.34,4.34,0,0,0-.52-2.452.574.574,0,0,0-.359-.1c-1.061,0-3.465,1.411-3.936,1.694a16.644,16.644,0,0,0-4.2-.489,16.379,16.379,0,0,0-3.969.445c-.846-.5-2.91-1.649-3.859-1.649a.566.566,0,0,0-.354.095,4.3,4.3,0,0,0-.521,2.452,6.7,6.7,0,0,0,.244,1.718,7.346,7.346,0,0,0-1.6,4.822,7.263,7.263,0,0,0,1.533,4.985c1.193,1.359,3.115,2.165,5.871,2.464a1.826,1.826,0,0,0-1.129,1.693v.5h0l-.006,0a7.121,7.121,0,0,1-2.033.363,2.608,2.608,0,0,1-.965-.158,4.438,4.438,0,0,1-1.836-1.881,2.361,2.361,0,0,0-1.248-1.091,3.472,3.472,0,0,0-1.217-.3.584.584,0,0,0-.545.224.282.282,0,0,0,.027.367,1.875,1.875,0,0,0,.447.307,4.732,4.732,0,0,1,.561.355,10.726,10.726,0,0,1,1.682,2.755c.043.092.078.163.105.217a3.876,3.876,0,0,0,2.42,1.185,6.036,6.036,0,0,0,.607.025c.875,0,1.988-.124,2-.125Z" transform="translate(11461 -1015)" fill="var(--footer-icons)"></path><g id="Ellipse_670" data-name="Ellipse 670" transform="translate(-13522.5 6994)" fill="none" stroke="var(--footer-icons)" stroke-width="1"><circle cx="16" cy="16" r="16" stroke="none"></circle><circle cx="16" cy="16" r="15.5" fill="none"></circle></g></g></g></svg></a></li><li class="social"><a href="https://linkedin.com/in/btholt"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="32" height="32" viewBox="0 0 32 32"><defs><clipPath id="clip-linkedin-social"><rect width="32" height="32"></rect></clipPath></defs><g id="linkedin-social" clip-path="url(#clip-linkedin-social)"><g id="Group_270" data-name="Group 270" transform="translate(-86.349 -633.073)"><path id="Path_375" data-name="Path 375" d="M115.789,633.073a2.324,2.324,0,0,1,1.682.676,2.194,2.194,0,0,1,.695,1.627V662.8a2.131,2.131,0,0,1-.695,1.609,2.314,2.314,0,0,1-1.646.659H88.69a2.307,2.307,0,0,1-1.646-.659,2.128,2.128,0,0,1-.695-1.609V635.376a2.19,2.19,0,0,1,.695-1.627,2.322,2.322,0,0,1,1.682-.676h27.063Zm-20.224,9.672a2.561,2.561,0,0,0,0-3.584,2.658,2.658,0,0,0-1.938-.712,2.724,2.724,0,0,0-1.957.712,2.371,2.371,0,0,0-.75,1.792,2.4,2.4,0,0,0,.731,1.792,2.605,2.605,0,0,0,1.9.713h.037A2.7,2.7,0,0,0,95.565,642.745ZM96,645.434H91.213V659.88H96Zm17.3,6.144a7.007,7.007,0,0,0-1.573-4.9,5.68,5.68,0,0,0-6.839-.769,5.663,5.663,0,0,0-1.426,1.573v-2.048H98.674q.036.841,0,7.717v6.728h4.791V651.8a3.592,3.592,0,0,1,.146-1.17,2.913,2.913,0,0,1,.878-1.206,2.429,2.429,0,0,1,1.609-.549,2.108,2.108,0,0,1,1.865.914,4.265,4.265,0,0,1,.549,2.341v7.752H113.3Z" fill="var(--footer-icons)"></path></g></g></svg></a></li><li class="social"><div class="terms"><p>Content Licensed Under CC-BY-NC-4.0</p><p>Code Samples and Exercises Licensed Under Apache 2.0</p><p>Site Designed by<!-- --> <a href="https://www.alexdanielson.com/">Alex Danielson</a></p></div></li></ul><div class="theme-icons"><button aria-label="Activate dark mode" title="Activate dark mode" class="theme-toggle"><svg xmlns="http://www.w3.org/2000/svg" width="36px" height="100%" viewBox="0 -960 960 960" fill="var(--text-footer)" role="img"><title>Dark Mode Icon</title><path d="M480-120q-150 0-255-105T120-480q0-150 105-255t255-105q14 0 27.5 1t26.5 3q-41 29-65.5 75.5T444-660q0 90 63 153t153 63q55 0 101-24.5t75-65.5q2 13 3 26.5t1 27.5q0 150-105 255T480-120Zm0-80q88 0 158-48.5T740-375q-20 5-40 8t-40 3q-123 0-209.5-86.5T364-660q0-20 3-40t8-40q-78 32-126.5 102T200-480q0 116 82 198t198 82Z"></path></svg></button></div></footer></div><noscript><img src="https://a.holt.courses/noscript.gif" alt="" referrerPolicy="no-referrer-when-downgrade"/></noscript></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"attributes":{"title":"JSON in PostgreSQL","description":"One of PostgreSQL's super powers is that it's able to store and query JSON"},"html":"\u003ch2\u003eError in this course\u003c/h2\u003e\n\u003cp\u003eThis course incorrectly chooses to use the \u003ccode\u003eJSON\u003c/code\u003e data type when it should have used the \u003ccode\u003eJSONB\u003c/code\u003e data type. Everything in this course will work with either one but when you\u0026#39;re creating your own database you almost always (let\u0026#39;s just say always) want to choose JSONB because it stores the data in a more queryable format and more optimized for querying whereas JSON is a glorified text field. So feel free to use \u003ccode\u003eJSONB\u003c/code\u003e everywhere where it says \u003ccode\u003eJSON\u003c/code\u003e or you can just use \u003ccode\u003eJSON\u003c/code\u003e knowing that when you go do it for yourself you\u0026#39;re going to use \u003ccode\u003eJSONB\u003c/code\u003e. I\u0026#39;ve correct the references in this doc from JSON to JSONB but the videos will still says JSON.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.citusdata.com/blog/2016/07/14/choosing-nosql-hstore-json-jsonb/\"\u003eFor more info read this blog post about it\u003c/a\u003e.\u003c/p\u003e\n\u003ch2\u003eJSON\u003c/h2\u003e\n\u003cp\u003eSometimes you have data that just doesn\u0026#39;t have a nice schema to it. If you tried to fit it into a table database like PostgreSQL, you would end having very generic field names that would have to be interprepted by code or you\u0026#39;d end up with multiple tables to be able describe different schemas. This is one place where document based databases like MongoDB really shine; their schemaless database works really well in these situations.\u003c/p\u003e\n\u003cp\u003eHowever PostgreSQL has a magic superpower here: the JSONB data type. This allows you to put JSONB objects into a column and then you can use SQL to query those objects.\u003c/p\u003e\n\u003cp\u003eLet\u0026#39;s make an example for our message board. You want to add a new feature that allows users to do rich content embeds in your message board. For starters they\u0026#39;ll be able to embed polls, images, and videos but you can imagine growing that in the future so they can embed tweets, documents, and other things we haven\u0026#39;t dreamed up yet. You want to maintain that future flexibility.\u003c/p\u003e\n\u003cp\u003eThis would be possible to model with a normal schema but it\u0026#39;d come out pretty ugly and hard to understand, and it\u0026#39;s impossible to anticipate all our future growth plans now. This is where the \u003ccode\u003eJSONB\u003c/code\u003e data type is going to really shine. These are the queries we ran to create them. (you don\u0026#39;t need to run them again)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-sql\"\u003e\u003cspan class=\"hljs-keyword\"\u003eDROP\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eTABLE\u003c/span\u003e IF \u003cspan class=\"hljs-keyword\"\u003eEXISTS\u003c/span\u003e rich_content;\n\n\u003cspan class=\"hljs-keyword\"\u003eCREATE TABLE\u003c/span\u003e rich_content (\n  content_id \u003cspan class=\"hljs-type\"\u003eINTEGER\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ePRIMARY KEY\u003c/span\u003e GENERATED ALWAYS \u003cspan class=\"hljs-keyword\"\u003eAS\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eIDENTITY\u003c/span\u003e,\n  comment_id \u003cspan class=\"hljs-type\"\u003eINT\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eREFERENCES\u003c/span\u003e comments(comment_id) \u003cspan class=\"hljs-keyword\"\u003eON\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eDELETE\u003c/span\u003e CASCADE,\n  content JSONB \u003cspan class=\"hljs-keyword\"\u003eNOT NULL\u003c/span\u003e\n);\n\n\u003cspan class=\"hljs-keyword\"\u003eINSERT INTO\u003c/span\u003e rich_content\n  (comment_id, content)\n\u003cspan class=\"hljs-keyword\"\u003eVALUES\u003c/span\u003e\n  (\u003cspan class=\"hljs-number\"\u003e63\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;{ \u0026quot;type\u0026quot;: \u0026quot;poll\u0026quot;, \u0026quot;question\u0026quot;: \u0026quot;What is your favorite color?\u0026quot;, \u0026quot;options\u0026quot;: [\u0026quot;blue\u0026quot;, \u0026quot;red\u0026quot;, \u0026quot;green\u0026quot;, \u0026quot;yellow\u0026quot;] }\u0026#x27;\u003c/span\u003e),\n  (\u003cspan class=\"hljs-number\"\u003e358\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;{ \u0026quot;type\u0026quot;: \u0026quot;video\u0026quot;, \u0026quot;url\u0026quot;: \u0026quot;https://youtu.be/dQw4w9WgXcQ\u0026quot;, \u0026quot;dimensions\u0026quot;: { \u0026quot;height\u0026quot;: 1080, \u0026quot;width\u0026quot;: 1920 }}\u0026#x27;\u003c/span\u003e),\n  (\u003cspan class=\"hljs-number\"\u003e358\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;{ \u0026quot;type\u0026quot;: \u0026quot;poll\u0026quot;, \u0026quot;question\u0026quot;: \u0026quot;Is this your favorite video?\u0026quot;, \u0026quot;options\u0026quot;: [\u0026quot;yes\u0026quot;, \u0026quot;no\u0026quot;, \u0026quot;oh you\u0026quot;] }\u0026#x27;\u003c/span\u003e),\n  (\u003cspan class=\"hljs-number\"\u003e410\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;{ \u0026quot;type\u0026quot;: \u0026quot;image\u0026quot;, \u0026quot;url\u0026quot;: \u0026quot;https://btholt.github.io/complete-intro-to-linux-and-the-cli/WORDMARK-Small.png\u0026quot;, \u0026quot;dimensions\u0026quot;: { \u0026quot;height\u0026quot;: 400, \u0026quot;width\u0026quot;: 1084 }}\u0026#x27;\u003c/span\u003e),\n  (\u003cspan class=\"hljs-number\"\u003e485\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;{ \u0026quot;type\u0026quot;: \u0026quot;image\u0026quot;, \u0026quot;url\u0026quot;: \u0026quot;https://btholt.github.io/complete-intro-to-linux-and-the-cli/HEADER.png\u0026quot;, \u0026quot;dimensions\u0026quot;: { \u0026quot;height\u0026quot;: 237 , \u0026quot;width\u0026quot;: 3301 }}\u0026#x27;\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eThe \u003ccode\u003eJSONB\u003c/code\u003e data type is the shining star here. This allows us to insert JSON objects to be queried later.\u003c/li\u003e\n\u003cli\u003ePostgreSQL won\u0026#39;t let you insert malformatted JSON so it does validate it for you.\u003c/li\u003e\n\u003cli\u003eNotice you can have as much nesting as you want. Any valid JSON is valid here.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo let\u0026#39;s do some querying! We\u0026#39;re going to use two new symbols, \u003ccode\u003e-\u0026gt;\u003c/code\u003e and \u003ccode\u003e-\u0026gt;\u0026gt;\u003c/code\u003e. The \u003ccode\u003e-\u0026gt;\u003c/code\u003e means \u0026quot;give me back the JSON object\u0026quot;. The return type will be a JSON object, even if it\u0026#39;s just a string. It\u0026#39;s basically a black box to PostgreSQL and it treats all JSON the same, whether it\u0026#39;s an array, object, or just a string. The \u003ccode\u003e-\u0026gt;\u0026gt;\u003c/code\u003e means \u0026quot;give me this back as a string.\u0026quot;\u003c/p\u003e\n\u003cp\u003eFind the all the different types of rich content.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-sql\"\u003e\u003cspan class=\"hljs-keyword\"\u003eSELECT\u003c/span\u003e content \u003cspan class=\"hljs-operator\"\u003e-\u003c/span\u003e\u003cspan class=\"hljs-operator\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;type\u0026#x27;\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e rich_content;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eYou\u0026#39;ll get something like this\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-md\"\u003e\u003cspan class=\"hljs-section\"\u003e## ?column?\u003c/span\u003e\n\n\u0026quot;poll\u0026quot;\n\u0026quot;video\u0026quot;\n\u0026quot;poll\u0026quot;\n\u0026quot;image\u0026quot;\n\u0026quot;image\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIt repeats poll and image twice because there\u0026#39;s two of those. What if we just wanted the distinct options and no repeats? GROUP BY would work but let\u0026#39;s detour to talk about \u003ccode\u003eSELECT DISTINCT\u003c/code\u003e. SELECT DISTINCT will deduplicate your results for you. Try this (this will error)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-sql\"\u003e\u003cspan class=\"hljs-keyword\"\u003eSELECT\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eDISTINCT\u003c/span\u003e content \u003cspan class=\"hljs-operator\"\u003e-\u003c/span\u003e\u003cspan class=\"hljs-operator\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;type\u0026#x27;\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e rich_content;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003ePostgreSQL doesn\u0026#39;t actually know what data type it\u0026#39;s going to get back from JSON so it refuses to do any sort of comparisons with the results. We have to tell PostgreSQL \u0026quot;this is definitely going to be text.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-sql\"\u003e\u003cspan class=\"hljs-keyword\"\u003eSELECT\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eDISTINCT\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eCAST\u003c/span\u003e(content \u003cspan class=\"hljs-operator\"\u003e-\u003c/span\u003e\u003cspan class=\"hljs-operator\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;type\u0026#x27;\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eAS\u003c/span\u003e TEXT) \u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e rich_content;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eHowever this is a ton easier if you just \u003ccode\u003e-\u0026gt;\u0026gt;\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-sql\"\u003e\u003cspan class=\"hljs-keyword\"\u003eSELECT\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eDISTINCT\u003c/span\u003e content \u003cspan class=\"hljs-operator\"\u003e-\u003c/span\u003e\u003cspan class=\"hljs-operator\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;type\u0026#x27;\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e rich_content;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThat\u0026#39;s the key difference between \u003ccode\u003e-\u0026gt;\u003c/code\u003e and \u003ccode\u003e-\u0026gt;\u0026gt;\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eWhat if we wanted to only query for polls?\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-sql\"\u003e\u003cspan class=\"hljs-keyword\"\u003eSELECT\u003c/span\u003e content \u003cspan class=\"hljs-operator\"\u003e-\u003c/span\u003e\u003cspan class=\"hljs-operator\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;type\u0026#x27;\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eAS\u003c/span\u003e content_type, comment_id \u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e rich_content \u003cspan class=\"hljs-keyword\"\u003eWHERE\u003c/span\u003e content \u003cspan class=\"hljs-operator\"\u003e-\u003c/span\u003e\u003cspan class=\"hljs-operator\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;type\u0026#x27;\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;poll\u0026#x27;\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eUnfortunately due to the execution order (WHERE happens before SELECT) you can\u0026#39;t reference content_type and have to give it the full expression.\u003c/p\u003e\n\u003cp\u003eOkay, last one. What if we wanted to find all the widths and heights?\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-sql\"\u003e\u003cspan class=\"hljs-keyword\"\u003eSELECT\u003c/span\u003e\n  content \u003cspan class=\"hljs-operator\"\u003e-\u003c/span\u003e\u003cspan class=\"hljs-operator\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;dimensions\u0026#x27;\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e-\u003c/span\u003e\u003cspan class=\"hljs-operator\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;height\u0026#x27;\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eAS\u003c/span\u003e height,\n  content \u003cspan class=\"hljs-operator\"\u003e-\u003c/span\u003e\u003cspan class=\"hljs-operator\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;dimensions\u0026#x27;\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e-\u003c/span\u003e\u003cspan class=\"hljs-operator\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;width\u0026#x27;\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eAS\u003c/span\u003e width,\n  comment_id\n\u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e\n  rich_content;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eYou can use the \u003ccode\u003e-\u0026gt;\u003c/code\u003e and \u003ccode\u003e-\u0026gt;\u0026gt;\u003c/code\u003e multiple times to look at nested values. This will give you back the ones that don\u0026#39;t have heights and widths too. To filter those out just do:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-sql\"\u003e\u003cspan class=\"hljs-keyword\"\u003eSELECT\u003c/span\u003e\n  content \u003cspan class=\"hljs-operator\"\u003e-\u003c/span\u003e\u003cspan class=\"hljs-operator\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;dimensions\u0026#x27;\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e-\u003c/span\u003e\u003cspan class=\"hljs-operator\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;height\u0026#x27;\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eAS\u003c/span\u003e height,\n  content \u003cspan class=\"hljs-operator\"\u003e-\u003c/span\u003e\u003cspan class=\"hljs-operator\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;dimensions\u0026#x27;\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e-\u003c/span\u003e\u003cspan class=\"hljs-operator\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;width\u0026#x27;\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eAS\u003c/span\u003e width,\n  comment_id\n\u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e\n  rich_content\n\u003cspan class=\"hljs-keyword\"\u003eWHERE\u003c/span\u003e\n  content \u003cspan class=\"hljs-operator\"\u003e-\u003c/span\u003e\u003cspan class=\"hljs-operator\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;dimensions\u0026#x27;\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eIS\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eNOT NULL\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e","markdown":"\n## Error in this course\n\nThis course incorrectly chooses to use the `JSON` data type when it should have used the `JSONB` data type. Everything in this course will work with either one but when you're creating your own database you almost always (let's just say always) want to choose JSONB because it stores the data in a more queryable format and more optimized for querying whereas JSON is a glorified text field. So feel free to use `JSONB` everywhere where it says `JSON` or you can just use `JSON` knowing that when you go do it for yourself you're going to use `JSONB`. I've correct the references in this doc from JSON to JSONB but the videos will still says JSON.\n\n[For more info read this blog post about it][jsonb].\n\n## JSON\n\nSometimes you have data that just doesn't have a nice schema to it. If you tried to fit it into a table database like PostgreSQL, you would end having very generic field names that would have to be interprepted by code or you'd end up with multiple tables to be able describe different schemas. This is one place where document based databases like MongoDB really shine; their schemaless database works really well in these situations.\n\nHowever PostgreSQL has a magic superpower here: the JSONB data type. This allows you to put JSONB objects into a column and then you can use SQL to query those objects.\n\nLet's make an example for our message board. You want to add a new feature that allows users to do rich content embeds in your message board. For starters they'll be able to embed polls, images, and videos but you can imagine growing that in the future so they can embed tweets, documents, and other things we haven't dreamed up yet. You want to maintain that future flexibility.\n\nThis would be possible to model with a normal schema but it'd come out pretty ugly and hard to understand, and it's impossible to anticipate all our future growth plans now. This is where the `JSONB` data type is going to really shine. These are the queries we ran to create them. (you don't need to run them again)\n\n```sql\nDROP TABLE IF EXISTS rich_content;\n\nCREATE TABLE rich_content (\n  content_id INTEGER PRIMARY KEY GENERATED ALWAYS AS IDENTITY,\n  comment_id INT REFERENCES comments(comment_id) ON DELETE CASCADE,\n  content JSONB NOT NULL\n);\n\nINSERT INTO rich_content\n  (comment_id, content)\nVALUES\n  (63, '{ \"type\": \"poll\", \"question\": \"What is your favorite color?\", \"options\": [\"blue\", \"red\", \"green\", \"yellow\"] }'),\n  (358, '{ \"type\": \"video\", \"url\": \"https://youtu.be/dQw4w9WgXcQ\", \"dimensions\": { \"height\": 1080, \"width\": 1920 }}'),\n  (358, '{ \"type\": \"poll\", \"question\": \"Is this your favorite video?\", \"options\": [\"yes\", \"no\", \"oh you\"] }'),\n  (410, '{ \"type\": \"image\", \"url\": \"https://btholt.github.io/complete-intro-to-linux-and-the-cli/WORDMARK-Small.png\", \"dimensions\": { \"height\": 400, \"width\": 1084 }}'),\n  (485, '{ \"type\": \"image\", \"url\": \"https://btholt.github.io/complete-intro-to-linux-and-the-cli/HEADER.png\", \"dimensions\": { \"height\": 237 , \"width\": 3301 }}');\n```\n\n- The `JSONB` data type is the shining star here. This allows us to insert JSON objects to be queried later.\n- PostgreSQL won't let you insert malformatted JSON so it does validate it for you.\n- Notice you can have as much nesting as you want. Any valid JSON is valid here.\n\nSo let's do some querying! We're going to use two new symbols, `-\u003e` and `-\u003e\u003e`. The `-\u003e` means \"give me back the JSON object\". The return type will be a JSON object, even if it's just a string. It's basically a black box to PostgreSQL and it treats all JSON the same, whether it's an array, object, or just a string. The `-\u003e\u003e` means \"give me this back as a string.\"\n\nFind the all the different types of rich content.\n\n```sql\nSELECT content -\u003e 'type' FROM rich_content;\n```\n\nYou'll get something like this\n\n```md\n## ?column?\n\n\"poll\"\n\"video\"\n\"poll\"\n\"image\"\n\"image\"\n```\n\nIt repeats poll and image twice because there's two of those. What if we just wanted the distinct options and no repeats? GROUP BY would work but let's detour to talk about `SELECT DISTINCT`. SELECT DISTINCT will deduplicate your results for you. Try this (this will error)\n\n```sql\nSELECT DISTINCT content -\u003e 'type' FROM rich_content;\n```\n\nPostgreSQL doesn't actually know what data type it's going to get back from JSON so it refuses to do any sort of comparisons with the results. We have to tell PostgreSQL \"this is definitely going to be text.\n\n```sql\nSELECT DISTINCT CAST(content -\u003e 'type' AS TEXT) FROM rich_content;\n```\n\nHowever this is a ton easier if you just `-\u003e\u003e`\n\n```sql\nSELECT DISTINCT content -\u003e\u003e 'type' FROM rich_content;\n```\n\nThat's the key difference between `-\u003e` and `-\u003e\u003e`.\n\nWhat if we wanted to only query for polls?\n\n```sql\nSELECT content -\u003e\u003e 'type' AS content_type, comment_id FROM rich_content WHERE content -\u003e\u003e 'type' = 'poll';\n```\n\nUnfortunately due to the execution order (WHERE happens before SELECT) you can't reference content_type and have to give it the full expression.\n\nOkay, last one. What if we wanted to find all the widths and heights?\n\n```sql\nSELECT\n  content -\u003e 'dimensions' -\u003e\u003e 'height' AS height,\n  content -\u003e 'dimensions' -\u003e\u003e 'width' AS width,\n  comment_id\nFROM\n  rich_content;\n```\n\nYou can use the `-\u003e` and `-\u003e\u003e` multiple times to look at nested values. This will give you back the ones that don't have heights and widths too. To filter those out just do:\n\n```sql\nSELECT\n  content -\u003e 'dimensions' -\u003e\u003e 'height' AS height,\n  content -\u003e 'dimensions' -\u003e\u003e 'width' AS width,\n  comment_id\nFROM\n  rich_content\nWHERE\n  content -\u003e 'dimensions' IS NOT NULL;\n```\n\n[jsonb]: https://www.citusdata.com/blog/2016/07/14/choosing-nosql-hstore-json-jsonb/\n","slug":"json-in-postgresql","title":"JSON in PostgreSQL","section":"Sql","icon":"info-circle","filePath":"/home/runner/work/complete-intro-to-databases-v2/complete-intro-to-databases-v2/lessons/03-sql/E-json-in-postgresql.md","nextSlug":"/lessons/sql/indexes-in-postgresql","prevSlug":"/lessons/sql/complex-sql-queries"}},"__N_SSG":true},"page":"/lessons/[section]/[slug]","query":{"section":"sql","slug":"json-in-postgresql"},"buildId":"Ogv8p-BwCHRQ1PzRpAU9u","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>