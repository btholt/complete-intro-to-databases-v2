<!DOCTYPE html><html><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width" data-next-head=""/><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png" data-next-head=""/><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png" data-next-head=""/><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png" data-next-head=""/><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png" data-next-head=""/><link rel="icon" type="image/x-icon" href="/images/favicon.ico" data-next-head=""/><title data-next-head="">Complex Sql Queries – Complete Intro to Databases v2</title><meta name="description" content="Brian dives into how to compound queries, joins, unions, group bys, and other ways to get obtain powerful results with the expressiveness of SQL" data-next-head=""/><meta name="keywords" content="postgres,sql,redis,mongodb,neo4j,database,data,agents" data-next-head=""/><meta name="og:description" content="Brian dives into how to compound queries, joins, unions, group bys, and other ways to get obtain powerful results with the expressiveness of SQL" data-next-head=""/><meta name="og:title" content="Complex Sql Queries – Complete Intro to Databases v2" data-next-head=""/><meta name="og:image" content="/images/social-share-cover.jpg" data-next-head=""/><meta name="twitter:card" content="summary_large_image" data-next-head=""/><link data-next-font="size-adjust" rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/_next/static/chunks/3802a39ca373f962.css" as="style"/><link rel="stylesheet" href="/_next/static/chunks/3802a39ca373f962.css" data-n-g=""/><noscript data-n-css=""></noscript><script src="/_next/static/chunks/dbe15a90055bd265.js" defer=""></script><script src="/_next/static/chunks/49c75c2ed6206f46.js" defer=""></script><script src="/_next/static/chunks/da0ff8adaa6cce90.js" defer=""></script><script src="/_next/static/chunks/turbopack-342361b32f83e6b6.js" defer=""></script><script src="/_next/static/chunks/f189af6b04c7fd39.js" defer=""></script><script src="/_next/static/chunks/turbopack-8b35dea75ba6f85c.js" defer=""></script><script src="/_next/static/Ogv8p-BwCHRQ1PzRpAU9u/_ssgManifest.js" defer=""></script><script src="/_next/static/Ogv8p-BwCHRQ1PzRpAU9u/_buildManifest.js" defer=""></script></head><body><script async="" defer="" src="https://a.holt.courses/latest.js"></script><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"/><div id="__next"><link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&amp;display=swap" rel="stylesheet"/><div class="remix-app"><header class="navbar"><h1 class="navbar-brand"><a href="/">Complete Intro to Databases v2</a></h1><div class="navbar-info"><a href="https://frontendmasters.com/workshops/databases-v2/" class="cta-btn">Watch on Frontend Masters</a></div></header><div class="content-container"><div class="main"><div class="lesson-container"><div class="lesson"><div class="lesson-content"><p>Let&#39;s get into some more complicated querying. First thing we&#39;re going to need is two more tables, comments and boards. We&#39;ll be making the data structure for a very simple message board system that has users, comments, and boards. The interesting part here is that every comment is posted by a user and therefore will need to reference the user table, and it will be posted to board and therefore will need to reference a board from the boards table. This is what you would call relational data and where relational databases really shine.</p>
<h2>Foreign Keys</h2>
<p>Let&#39;s jot down all of our schemas for our users, boards, and comments.</p>
<pre><code class="hljs language-sql">
<span class="hljs-keyword">CREATE TABLE</span> users (
  user_id <span class="hljs-type">INTEGER</span> <span class="hljs-keyword">PRIMARY KEY</span> GENERATED ALWAYS <span class="hljs-keyword">AS</span> <span class="hljs-keyword">IDENTITY</span>,
  username <span class="hljs-type">VARCHAR</span> ( <span class="hljs-number">25</span> ) <span class="hljs-keyword">UNIQUE</span> <span class="hljs-keyword">NOT NULL</span>,
  email <span class="hljs-type">VARCHAR</span> ( <span class="hljs-number">50</span> ) <span class="hljs-keyword">UNIQUE</span> <span class="hljs-keyword">NOT NULL</span>,
  full_name <span class="hljs-type">VARCHAR</span> ( <span class="hljs-number">100</span> ) <span class="hljs-keyword">NOT NULL</span>,
  last_login <span class="hljs-type">TIMESTAMP</span>,
  created_on <span class="hljs-type">TIMESTAMP</span> <span class="hljs-keyword">NOT NULL</span>
);

<span class="hljs-keyword">CREATE TABLE</span> boards (
  board_id <span class="hljs-type">INTEGER</span> <span class="hljs-keyword">PRIMARY KEY</span> GENERATED ALWAYS <span class="hljs-keyword">AS</span> <span class="hljs-keyword">IDENTITY</span>,
  board_name <span class="hljs-type">VARCHAR</span> ( <span class="hljs-number">50</span> ) <span class="hljs-keyword">UNIQUE</span> <span class="hljs-keyword">NOT NULL</span>,
  board_description TEXT <span class="hljs-keyword">NOT NULL</span>
);

<span class="hljs-keyword">CREATE TABLE</span> comments (
  comment_id <span class="hljs-type">INTEGER</span> <span class="hljs-keyword">PRIMARY KEY</span> GENERATED ALWAYS <span class="hljs-keyword">AS</span> <span class="hljs-keyword">IDENTITY</span>,
  user_id <span class="hljs-type">INT</span> <span class="hljs-keyword">REFERENCES</span> users(user_id) <span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> CASCADE,
  board_id <span class="hljs-type">INT</span> <span class="hljs-keyword">REFERENCES</span> boards(board_id) <span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> CASCADE,
  comment TEXT <span class="hljs-keyword">NOT NULL</span>,
  <span class="hljs-type">time</span> <span class="hljs-type">TIMESTAMP</span>
);
</code></pre><ul>
<li>The first two should look pretty familiar. The only new-ish thing is the user of the <code>TEXT</code> data type. This is basically a VARCHAR with no cap (or rather a very large cap.) It has some other small differences but for now just know it&#39;s uncapped text.</li>
<li><code>user_id INT REFERENCES users(user_id)</code> is technically all you need to make a foreign key. The first part, <code>INT</code>, makes it known that this key will be stored as an integer. It then uses the <code>REFERENCES</code> key word to let PostgreSQL know that it is a foreign key. A foreign key is a field in one table that references the <strong>primary</strong> key of another table. In this case, a comment will reference the user_id in another table, the users table. The <code>users</code> part say it&#39;s reference the users table and the <code>(user_id)</code> is the name of the key in the other table. In this case, we called both user_id (which will probably happen somewhat frequently but not always) so they match but if we had called the user_id just id in the users table, we&#39;d put <code>id</code> there.</li>
<li><code>ON DELETE CASCADE</code> lets PostgreSQL know what to do if the user gets deleted. So if a user makes a comment on the message board and then deletes their account, what do you want it to do? If you omit the <code>ON DELETE CASCADE</code> part, it&#39;s the same as doing <code>ON DELETE NO ACTION</code> which means it&#39;ll just error and not let you delete the user until you&#39;ve deleted all the comments first. You can also do <code>ON DELETE SET NULL</code> which means it&#39;ll make the user_id null on any comment that was made by that user.</li>
<li>We&#39;ve dne the same for board_id, just referencing the boards table instead of the users table.</li>
</ul>
<p>Let&#39;s go ahead and put some dummy data in there. Copy / paste [this query] into your psql terminal. It may take a few minutes.</p>
<h2>JOIN</h2>
<p>So a user goes to your message board and click</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> comment_id, user_id, <span class="hljs-keyword">LEFT</span>(comment, <span class="hljs-number">20</span>) <span class="hljs-keyword">AS</span> preview <span class="hljs-keyword">FROM</span> comments <span class="hljs-keyword">WHERE</span> board_id <span class="hljs-operator">=</span> <span class="hljs-number">39</span>;
</code></pre><ul>
<li>Two new things here. The <code>LEFT</code> function will return the first X characters of a string (as you can guess, RIGHT returns the last X charcters). We&#39;r doing this because this hard to read otherwise in the command line.</li>
<li>The <code>AS</code> keyword lets you rename how the string is projected. If we don&#39;t use AS here, the string will be returned under they key <code>left</code> which doesn&#39;t make sense.</li>
</ul>
<p>Okay so you&#39;ll get something back like this:</p>
<pre><code> comment_id | user_id |       preview
------------+---------+----------------------
         63 |     858 | Maecenas tristique,
        358 |     876 | Mauris enim leo, rho
        429 |     789 | Maecenas ut massa qu
        463 |     925 | Phasellus sit amet e
        485 |     112 | Maecenas tristique,
        540 |     588 | Nullam porttitor lac
        545 |     587 | Praesent id massa id
        972 |     998 | Aenean lectus. Pelle
(8 rows)
</code></pre><p>We can&#39;t really use this to display the comments on our web app because your users don&#39;t care what user_id posted these comments, they want the username. But that doesn&#39;t live in the comments table, that exists in the users table. So how do we connect those together?</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span>
  comment_id, comments.user_id, users.username, <span class="hljs-type">time</span>, <span class="hljs-keyword">LEFT</span>(comment, <span class="hljs-number">20</span>) <span class="hljs-keyword">AS</span> preview
<span class="hljs-keyword">FROM</span>
  comments
<span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span>
  users
<span class="hljs-keyword">ON</span>
  comments.user_id <span class="hljs-operator">=</span> users.user_id
<span class="hljs-keyword">WHERE</span>
  board_id <span class="hljs-operator">=</span> <span class="hljs-number">39</span>;
</code></pre><p>Magic! The big key here is the <code>INNER JOIN</code> which allows us to match up all the keys from one table to another. We do that in <code>ON</code> clause where we say user<em>ids match is where you can _join</em> together those records into one record.</p>
<p>Let&#39;s talk about <code>INNER</code> for a second. There are multiple kinds of JOINs. INNER is a good one start with. It says &quot;find where user_ids match. If you find a record where the user_id exists in one but not in the other, omit it in the results.&quot; This isn&#39;t a particularly useful distinction for us right now becase all user_ids will exist in users and we&#39;re assured of that due to the foreign key restraints we used. However if a comment had a user_id that didn&#39;t exist, it would omit that comment in the results.</p>
<p><a href="https://commons.wikimedia.org/wiki/File:SQL_Joins.svg"><img src="./images/SQL_Joins.png" alt="diagram of SQL joins"></a></p>
<p>A <code>LEFT JOIN</code> would say &quot;if a comment has a user_id that doesn&#39;t exist, include it anyway.&quot; A <code>RIGHT JOIN</code> wouldn&#39;t make much sense here but it would include users even if they didn&#39;t have a comment on that board.</p>
<p>We can also an <code>OUTER JOIN</code> which would be everything that <em>doesn&#39;t match</em>. In our database, that would be nothing because we&#39;re guaranteed everything has match due to our constraints.</p>
<p>You can also do a <code>FULL OUTER JOIN</code> which says just include everything. If it doesn&#39;t have a match from either side, include it. If it does have a match, include it.</p>
<p>Another rarely useful join is the <code>CROSS JOIN</code>. This gives the <em>Cartesian product</em> of the two tables which can be enormous. A Cartesian product would be every row matched with every other row in the other table. If you have A, B, and C in one table with D and E in the other, your CROSS JOIN would be AD, AE, BD, BE, CD, an CE. If you do a cross join between two tables with 1,000 rows each, you&#39;d get 1,000,000 records back.</p>
<p>Tables can also be self-joined. Imagine you have a table of employees and one of the fields is direct_reports which contains employee_ids of employees that report the original employee. You could do a SELF JOIN to get the information for the reports.</p>
<p>Honestly 95% of what I do is covered by INNER and LEFT joins.</p>
<p>One neat trick we could do here is a NATURAL JOIN.</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span>
  comment_id, comments.user_id, users.username, <span class="hljs-type">time</span>, <span class="hljs-keyword">LEFT</span>(comment, <span class="hljs-number">20</span>) <span class="hljs-keyword">AS</span> preview
<span class="hljs-keyword">FROM</span>
  comments
<span class="hljs-keyword">NATURAL</span> <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span>
  users
<span class="hljs-keyword">WHERE</span>
  board_id <span class="hljs-operator">=</span> <span class="hljs-number">39</span>;
</code></pre><p>This will work like it did above. NATURAL JOIN tells PostgreSQL &quot;I named things the same in both tables, go ahead and match it together yourself. This is fun when it lines up but I don&#39;t often end up using it myself. And in the end it&#39;s often better to be explicit what about your intent is for joins. So use cautiously and/or for neat party tricks.</p>
<h2>Subqueries</h2>
<p>Let&#39;s say you need to find all the comments made by Maynord Simonich. You could make two queries: query for Kate&#39;s user_id from users, and then use that user_id to query comments. Or we could do it all at once with a subquery!</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> comment_id, user_id, <span class="hljs-keyword">LEFT</span>(comment, <span class="hljs-number">20</span>) <span class="hljs-keyword">FROM</span> comments <span class="hljs-keyword">WHERE</span> user_id <span class="hljs-operator">=</span> (<span class="hljs-keyword">SELECT</span> user_id <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> full_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Maynord Simonich&#x27;</span>);
</code></pre><p>This will query for Maynord&#39;s ID and immediately use that in the other query. Make sure this returns exactly one row or this will fail. You can use subqueries in a variety of ways but it generally looks like this with <code>()</code> surrounding the subqueries. You can even have subqueries in your subqueries!</p>
<h2>GROUP BY</h2>
<p>What if you were making a report and you wanted to show the top ten most posted-to message boards? You could run something like this.</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span>
  boards.board_name, <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">AS</span> comment_count
<span class="hljs-keyword">FROM</span>
  comments
<span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span>
  boards
<span class="hljs-keyword">ON</span>
  boards.board_id <span class="hljs-operator">=</span> comments.board_id
<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span>
  boards.board_name
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>
  comment_count <span class="hljs-keyword">DESC</span>
LIMIT <span class="hljs-number">10</span>;
</code></pre><p><code>GROUP BY</code> is going to collapse all the same board_names (guaranteed unique due to our UNIQUE constraint on the board) and then we use the <code>COUNT(*)</code> to count how many boards have that same <code>board_name</code>. So this works! This will give us the precise number of comments on the top board!</p>
<p>Now what if you wanted to see the boards that were the least populated? We could just flip the <code>ORDER BY</code> to <code>ASC</code> but there&#39;s a distinct problem here: what happens if there&#39;s no post on a board?</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span>
  boards.board_name, <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">AS</span> comment_count
<span class="hljs-keyword">FROM</span>
  comments
<span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span>
  boards
<span class="hljs-keyword">ON</span>
  boards.board_id <span class="hljs-operator">=</span> comments.board_id
<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span>
  boards.board_name
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>
  comment_count <span class="hljs-keyword">ASC</span>
LIMIT <span class="hljs-number">10</span>;
</code></pre><p>It wouldn&#39;t show up because of the <code>INNER JOIN</code>. So what do we need? Well, the &quot;LEFT&quot; board here is the comments (the one that&#39;s in the FROM will be LEFT) and we don&#39;t need anything more from the comments board since all of them will show up in the query thanks to the foreign key constraints. So then we need a RIGHT JOIN! We need to include boards that don&#39;t have any comments. We also need to change <code>COUNT(*)</code> because any row counts for a <code>*</code> and that would make it look like there was one comment on our empty boards when in reality there was zero. We need therefore it to be <code>COUNT(comment_id)</code> because that will actually count how many comments exist.</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span>
  boards.board_name, <span class="hljs-built_in">COUNT</span>(comment_id) <span class="hljs-keyword">AS</span> comment_count
<span class="hljs-keyword">FROM</span>
  comments
<span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span>
  boards
<span class="hljs-keyword">ON</span>
  boards.board_id <span class="hljs-operator">=</span> comments.board_id
<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span>
  boards.board_name
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>
  comment_count;
</code></pre><p>Tricky! It&#39;s important to know your data, what you expect to see, and be aware of the constraints of your queries!</p>
</div><div class="lesson-links"><a class="prev" href="/lessons/sql/querying-postgresql">← Previous</a><a class="next" href="/lessons/sql/json-in-postgresql">Next →</a></div></div><div class="details-bg"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="154" height="154" viewBox="0 0 154 154"><defs><clipPath id="clip-path"><rect id="Rectangle_2238" data-name="Rectangle 2238" width="154" height="154" transform="translate(9467 350)" fill="#fff" stroke="#707070" stroke-width="1"></rect></clipPath><clipPath id="clip-corner-image-active"><rect width="154" height="154"></rect></clipPath></defs><g id="corner-image-active" clip-path="url(#clip-corner-image-active)"><g id="Corner-image-active-2" data-name="Corner-image-active" transform="translate(-9467 -350)" clip-path="url(#clip-path)"><path id="Subtraction_34" data-name="Subtraction 34" d="M-3857.365,1740.766h0l-7.07-7.07,12.89-12.89v14.142l-5.818,5.818Zm-14.142-14.142h0l-7.071-7.07,27.033-27.033v14.143l-19.96,19.96Zm-14.143-14.143h0l-7.07-7.069,41.175-41.175v14.142Zm-14.142-14.142h0l-7.07-7.069,55.317-55.317v14.142Zm-14.142-14.142h0l-7.07-7.069,69.459-69.459v14.142Zm-14.142-14.142h0l-7.07-7.069,76.739-76.739h6.862v7.28Zm-14.143-14.143h0l-7.07-7.069,62.6-62.6h14.142Zm-14.142-14.142h0l-7.07-7.069,48.454-48.454h14.142Zm-14.142-14.142h0l-7.07-7.069,34.312-34.312h14.142Zm-14.142-14.142h0l-7.07-7.069,20.17-20.17h14.142Zm-14.142-14.142h0l-7.071-7.071,6.027-6.027h14.144l-13.1,13.1Zm367.24-56.114v-.909l.455.455-.453.453Z" transform="translate(13472.546 -1236.766)" fill="var(--corner-fill)"></path></g></g></svg></div></div></div></div><footer class="footer"><ul class="socials"><li class="social"><a href="https://twitter.com/holtbt"><svg fill="none" height="100%" width="32" xmlns="http://www.w3.org/2000/svg" viewBox="0.254 0.25 500 451.95400000000006"><path d="M394.033.25h76.67L303.202 191.693l197.052 260.511h-154.29L225.118 294.205 86.844 452.204H10.127l179.16-204.77L.254.25H158.46l109.234 144.417zm-26.908 406.063h42.483L135.377 43.73h-45.59z" fill="var(--footer-icons)"></path></svg></a></li><li class="social"><a href="https://bsky.app/profile/brianholt.me"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 -3.268 64 68.414" width="38" height="100%"><path fill="var(--footer-icons)" d="M13.873 3.805C21.21 9.332 29.103 20.537 32 26.55v15.882c0-.338-.13.044-.41.867-1.512 4.456-7.418 21.847-20.923 7.944-7.111-7.32-3.819-14.64 9.125-16.85-7.405 1.264-15.73-.825-18.014-9.015C1.12 23.022 0 8.51 0 6.55 0-3.268 8.579-.182 13.873 3.805zm36.254 0C42.79 9.332 34.897 20.537 32 26.55v15.882c0-.338.13.044.41.867 1.512 4.456 7.418 21.847 20.923 7.944 7.111-7.32 3.819-14.64-9.125-16.85 7.405 1.264 15.73-.825 18.014-9.015C62.88 23.022 64 8.51 64 6.55c0-9.818-8.578-6.732-13.873-2.745z"></path></svg></a></li><li class="social"><a href="https://github.com/btholt"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="32" height="32" viewBox="0 0 32 32"><defs><clipPath id="clip-github-social"><rect width="32" height="32"></rect></clipPath></defs><g id="github-social" clip-path="url(#clip-github-social)"><g id="Group_272" data-name="Group 272" transform="translate(13522.5 -6994)"><path id="Subtraction_33" data-name="Subtraction 33" d="M-24967.5,8041a15.9,15.9,0,0,1-11.312-4.688A15.893,15.893,0,0,1-24983.5,8025a15.893,15.893,0,0,1,4.689-11.315A15.894,15.894,0,0,1-24967.5,8009a15.894,15.894,0,0,1,11.313,4.686A15.893,15.893,0,0,1-24951.5,8025a15.893,15.893,0,0,1-4.689,11.313A15.9,15.9,0,0,1-24967.5,8041Zm-3.781-4.571h0v3.918h7.895v-6.665a1.836,1.836,0,0,0-1.2-1.718c5.1-.617,7.467-2.975,7.467-7.424a7.176,7.176,0,0,0-1.637-4.728,6.74,6.74,0,0,0,.275-1.812,4.34,4.34,0,0,0-.52-2.452.574.574,0,0,0-.359-.1c-1.061,0-3.465,1.411-3.936,1.694a16.644,16.644,0,0,0-4.2-.489,16.379,16.379,0,0,0-3.969.445c-.846-.5-2.91-1.649-3.859-1.649a.566.566,0,0,0-.354.095,4.3,4.3,0,0,0-.521,2.452,6.7,6.7,0,0,0,.244,1.718,7.346,7.346,0,0,0-1.6,4.822,7.263,7.263,0,0,0,1.533,4.985c1.193,1.359,3.115,2.165,5.871,2.464a1.826,1.826,0,0,0-1.129,1.693v.5h0l-.006,0a7.121,7.121,0,0,1-2.033.363,2.608,2.608,0,0,1-.965-.158,4.438,4.438,0,0,1-1.836-1.881,2.361,2.361,0,0,0-1.248-1.091,3.472,3.472,0,0,0-1.217-.3.584.584,0,0,0-.545.224.282.282,0,0,0,.027.367,1.875,1.875,0,0,0,.447.307,4.732,4.732,0,0,1,.561.355,10.726,10.726,0,0,1,1.682,2.755c.043.092.078.163.105.217a3.876,3.876,0,0,0,2.42,1.185,6.036,6.036,0,0,0,.607.025c.875,0,1.988-.124,2-.125Z" transform="translate(11461 -1015)" fill="var(--footer-icons)"></path><g id="Ellipse_670" data-name="Ellipse 670" transform="translate(-13522.5 6994)" fill="none" stroke="var(--footer-icons)" stroke-width="1"><circle cx="16" cy="16" r="16" stroke="none"></circle><circle cx="16" cy="16" r="15.5" fill="none"></circle></g></g></g></svg></a></li><li class="social"><a href="https://linkedin.com/in/btholt"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="32" height="32" viewBox="0 0 32 32"><defs><clipPath id="clip-linkedin-social"><rect width="32" height="32"></rect></clipPath></defs><g id="linkedin-social" clip-path="url(#clip-linkedin-social)"><g id="Group_270" data-name="Group 270" transform="translate(-86.349 -633.073)"><path id="Path_375" data-name="Path 375" d="M115.789,633.073a2.324,2.324,0,0,1,1.682.676,2.194,2.194,0,0,1,.695,1.627V662.8a2.131,2.131,0,0,1-.695,1.609,2.314,2.314,0,0,1-1.646.659H88.69a2.307,2.307,0,0,1-1.646-.659,2.128,2.128,0,0,1-.695-1.609V635.376a2.19,2.19,0,0,1,.695-1.627,2.322,2.322,0,0,1,1.682-.676h27.063Zm-20.224,9.672a2.561,2.561,0,0,0,0-3.584,2.658,2.658,0,0,0-1.938-.712,2.724,2.724,0,0,0-1.957.712,2.371,2.371,0,0,0-.75,1.792,2.4,2.4,0,0,0,.731,1.792,2.605,2.605,0,0,0,1.9.713h.037A2.7,2.7,0,0,0,95.565,642.745ZM96,645.434H91.213V659.88H96Zm17.3,6.144a7.007,7.007,0,0,0-1.573-4.9,5.68,5.68,0,0,0-6.839-.769,5.663,5.663,0,0,0-1.426,1.573v-2.048H98.674q.036.841,0,7.717v6.728h4.791V651.8a3.592,3.592,0,0,1,.146-1.17,2.913,2.913,0,0,1,.878-1.206,2.429,2.429,0,0,1,1.609-.549,2.108,2.108,0,0,1,1.865.914,4.265,4.265,0,0,1,.549,2.341v7.752H113.3Z" fill="var(--footer-icons)"></path></g></g></svg></a></li><li class="social"><div class="terms"><p>Content Licensed Under CC-BY-NC-4.0</p><p>Code Samples and Exercises Licensed Under Apache 2.0</p><p>Site Designed by<!-- --> <a href="https://www.alexdanielson.com/">Alex Danielson</a></p></div></li></ul><div class="theme-icons"><button aria-label="Activate dark mode" title="Activate dark mode" class="theme-toggle"><svg xmlns="http://www.w3.org/2000/svg" width="36px" height="100%" viewBox="0 -960 960 960" fill="var(--text-footer)" role="img"><title>Dark Mode Icon</title><path d="M480-120q-150 0-255-105T120-480q0-150 105-255t255-105q14 0 27.5 1t26.5 3q-41 29-65.5 75.5T444-660q0 90 63 153t153 63q55 0 101-24.5t75-65.5q2 13 3 26.5t1 27.5q0 150-105 255T480-120Zm0-80q88 0 158-48.5T740-375q-20 5-40 8t-40 3q-123 0-209.5-86.5T364-660q0-20 3-40t8-40q-78 32-126.5 102T200-480q0 116 82 198t198 82Z"></path></svg></button></div></footer></div><noscript><img src="https://a.holt.courses/noscript.gif" alt="" referrerPolicy="no-referrer-when-downgrade"/></noscript></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"attributes":{"description":"Brian dives into how to compound queries, joins, unions, group bys, and other ways to get obtain powerful results with the expressiveness of SQL"},"html":"\u003cp\u003eLet\u0026#39;s get into some more complicated querying. First thing we\u0026#39;re going to need is two more tables, comments and boards. We\u0026#39;ll be making the data structure for a very simple message board system that has users, comments, and boards. The interesting part here is that every comment is posted by a user and therefore will need to reference the user table, and it will be posted to board and therefore will need to reference a board from the boards table. This is what you would call relational data and where relational databases really shine.\u003c/p\u003e\n\u003ch2\u003eForeign Keys\u003c/h2\u003e\n\u003cp\u003eLet\u0026#39;s jot down all of our schemas for our users, boards, and comments.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-sql\"\u003e\n\u003cspan class=\"hljs-keyword\"\u003eCREATE TABLE\u003c/span\u003e users (\n  user_id \u003cspan class=\"hljs-type\"\u003eINTEGER\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ePRIMARY KEY\u003c/span\u003e GENERATED ALWAYS \u003cspan class=\"hljs-keyword\"\u003eAS\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eIDENTITY\u003c/span\u003e,\n  username \u003cspan class=\"hljs-type\"\u003eVARCHAR\u003c/span\u003e ( \u003cspan class=\"hljs-number\"\u003e25\u003c/span\u003e ) \u003cspan class=\"hljs-keyword\"\u003eUNIQUE\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eNOT NULL\u003c/span\u003e,\n  email \u003cspan class=\"hljs-type\"\u003eVARCHAR\u003c/span\u003e ( \u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e ) \u003cspan class=\"hljs-keyword\"\u003eUNIQUE\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eNOT NULL\u003c/span\u003e,\n  full_name \u003cspan class=\"hljs-type\"\u003eVARCHAR\u003c/span\u003e ( \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e ) \u003cspan class=\"hljs-keyword\"\u003eNOT NULL\u003c/span\u003e,\n  last_login \u003cspan class=\"hljs-type\"\u003eTIMESTAMP\u003c/span\u003e,\n  created_on \u003cspan class=\"hljs-type\"\u003eTIMESTAMP\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eNOT NULL\u003c/span\u003e\n);\n\n\u003cspan class=\"hljs-keyword\"\u003eCREATE TABLE\u003c/span\u003e boards (\n  board_id \u003cspan class=\"hljs-type\"\u003eINTEGER\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ePRIMARY KEY\u003c/span\u003e GENERATED ALWAYS \u003cspan class=\"hljs-keyword\"\u003eAS\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eIDENTITY\u003c/span\u003e,\n  board_name \u003cspan class=\"hljs-type\"\u003eVARCHAR\u003c/span\u003e ( \u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e ) \u003cspan class=\"hljs-keyword\"\u003eUNIQUE\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eNOT NULL\u003c/span\u003e,\n  board_description TEXT \u003cspan class=\"hljs-keyword\"\u003eNOT NULL\u003c/span\u003e\n);\n\n\u003cspan class=\"hljs-keyword\"\u003eCREATE TABLE\u003c/span\u003e comments (\n  comment_id \u003cspan class=\"hljs-type\"\u003eINTEGER\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ePRIMARY KEY\u003c/span\u003e GENERATED ALWAYS \u003cspan class=\"hljs-keyword\"\u003eAS\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eIDENTITY\u003c/span\u003e,\n  user_id \u003cspan class=\"hljs-type\"\u003eINT\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eREFERENCES\u003c/span\u003e users(user_id) \u003cspan class=\"hljs-keyword\"\u003eON\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eDELETE\u003c/span\u003e CASCADE,\n  board_id \u003cspan class=\"hljs-type\"\u003eINT\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eREFERENCES\u003c/span\u003e boards(board_id) \u003cspan class=\"hljs-keyword\"\u003eON\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eDELETE\u003c/span\u003e CASCADE,\n  comment TEXT \u003cspan class=\"hljs-keyword\"\u003eNOT NULL\u003c/span\u003e,\n  \u003cspan class=\"hljs-type\"\u003etime\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eTIMESTAMP\u003c/span\u003e\n);\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eThe first two should look pretty familiar. The only new-ish thing is the user of the \u003ccode\u003eTEXT\u003c/code\u003e data type. This is basically a VARCHAR with no cap (or rather a very large cap.) It has some other small differences but for now just know it\u0026#39;s uncapped text.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003euser_id INT REFERENCES users(user_id)\u003c/code\u003e is technically all you need to make a foreign key. The first part, \u003ccode\u003eINT\u003c/code\u003e, makes it known that this key will be stored as an integer. It then uses the \u003ccode\u003eREFERENCES\u003c/code\u003e key word to let PostgreSQL know that it is a foreign key. A foreign key is a field in one table that references the \u003cstrong\u003eprimary\u003c/strong\u003e key of another table. In this case, a comment will reference the user_id in another table, the users table. The \u003ccode\u003eusers\u003c/code\u003e part say it\u0026#39;s reference the users table and the \u003ccode\u003e(user_id)\u003c/code\u003e is the name of the key in the other table. In this case, we called both user_id (which will probably happen somewhat frequently but not always) so they match but if we had called the user_id just id in the users table, we\u0026#39;d put \u003ccode\u003eid\u003c/code\u003e there.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eON DELETE CASCADE\u003c/code\u003e lets PostgreSQL know what to do if the user gets deleted. So if a user makes a comment on the message board and then deletes their account, what do you want it to do? If you omit the \u003ccode\u003eON DELETE CASCADE\u003c/code\u003e part, it\u0026#39;s the same as doing \u003ccode\u003eON DELETE NO ACTION\u003c/code\u003e which means it\u0026#39;ll just error and not let you delete the user until you\u0026#39;ve deleted all the comments first. You can also do \u003ccode\u003eON DELETE SET NULL\u003c/code\u003e which means it\u0026#39;ll make the user_id null on any comment that was made by that user.\u003c/li\u003e\n\u003cli\u003eWe\u0026#39;ve dne the same for board_id, just referencing the boards table instead of the users table.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eLet\u0026#39;s go ahead and put some dummy data in there. Copy / paste [this query] into your psql terminal. It may take a few minutes.\u003c/p\u003e\n\u003ch2\u003eJOIN\u003c/h2\u003e\n\u003cp\u003eSo a user goes to your message board and click\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-sql\"\u003e\u003cspan class=\"hljs-keyword\"\u003eSELECT\u003c/span\u003e comment_id, user_id, \u003cspan class=\"hljs-keyword\"\u003eLEFT\u003c/span\u003e(comment, \u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003eAS\u003c/span\u003e preview \u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e comments \u003cspan class=\"hljs-keyword\"\u003eWHERE\u003c/span\u003e board_id \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e39\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eTwo new things here. The \u003ccode\u003eLEFT\u003c/code\u003e function will return the first X characters of a string (as you can guess, RIGHT returns the last X charcters). We\u0026#39;r doing this because this hard to read otherwise in the command line.\u003c/li\u003e\n\u003cli\u003eThe \u003ccode\u003eAS\u003c/code\u003e keyword lets you rename how the string is projected. If we don\u0026#39;t use AS here, the string will be returned under they key \u003ccode\u003eleft\u003c/code\u003e which doesn\u0026#39;t make sense.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOkay so you\u0026#39;ll get something back like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e comment_id | user_id |       preview\n------------+---------+----------------------\n         63 |     858 | Maecenas tristique,\n        358 |     876 | Mauris enim leo, rho\n        429 |     789 | Maecenas ut massa qu\n        463 |     925 | Phasellus sit amet e\n        485 |     112 | Maecenas tristique,\n        540 |     588 | Nullam porttitor lac\n        545 |     587 | Praesent id massa id\n        972 |     998 | Aenean lectus. Pelle\n(8 rows)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWe can\u0026#39;t really use this to display the comments on our web app because your users don\u0026#39;t care what user_id posted these comments, they want the username. But that doesn\u0026#39;t live in the comments table, that exists in the users table. So how do we connect those together?\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-sql\"\u003e\u003cspan class=\"hljs-keyword\"\u003eSELECT\u003c/span\u003e\n  comment_id, comments.user_id, users.username, \u003cspan class=\"hljs-type\"\u003etime\u003c/span\u003e, \u003cspan class=\"hljs-keyword\"\u003eLEFT\u003c/span\u003e(comment, \u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003eAS\u003c/span\u003e preview\n\u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e\n  comments\n\u003cspan class=\"hljs-keyword\"\u003eINNER\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eJOIN\u003c/span\u003e\n  users\n\u003cspan class=\"hljs-keyword\"\u003eON\u003c/span\u003e\n  comments.user_id \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e users.user_id\n\u003cspan class=\"hljs-keyword\"\u003eWHERE\u003c/span\u003e\n  board_id \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e39\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eMagic! The big key here is the \u003ccode\u003eINNER JOIN\u003c/code\u003e which allows us to match up all the keys from one table to another. We do that in \u003ccode\u003eON\u003c/code\u003e clause where we say user\u003cem\u003eids match is where you can _join\u003c/em\u003e together those records into one record.\u003c/p\u003e\n\u003cp\u003eLet\u0026#39;s talk about \u003ccode\u003eINNER\u003c/code\u003e for a second. There are multiple kinds of JOINs. INNER is a good one start with. It says \u0026quot;find where user_ids match. If you find a record where the user_id exists in one but not in the other, omit it in the results.\u0026quot; This isn\u0026#39;t a particularly useful distinction for us right now becase all user_ids will exist in users and we\u0026#39;re assured of that due to the foreign key restraints we used. However if a comment had a user_id that didn\u0026#39;t exist, it would omit that comment in the results.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://commons.wikimedia.org/wiki/File:SQL_Joins.svg\"\u003e\u003cimg src=\"./images/SQL_Joins.png\" alt=\"diagram of SQL joins\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eA \u003ccode\u003eLEFT JOIN\u003c/code\u003e would say \u0026quot;if a comment has a user_id that doesn\u0026#39;t exist, include it anyway.\u0026quot; A \u003ccode\u003eRIGHT JOIN\u003c/code\u003e wouldn\u0026#39;t make much sense here but it would include users even if they didn\u0026#39;t have a comment on that board.\u003c/p\u003e\n\u003cp\u003eWe can also an \u003ccode\u003eOUTER JOIN\u003c/code\u003e which would be everything that \u003cem\u003edoesn\u0026#39;t match\u003c/em\u003e. In our database, that would be nothing because we\u0026#39;re guaranteed everything has match due to our constraints.\u003c/p\u003e\n\u003cp\u003eYou can also do a \u003ccode\u003eFULL OUTER JOIN\u003c/code\u003e which says just include everything. If it doesn\u0026#39;t have a match from either side, include it. If it does have a match, include it.\u003c/p\u003e\n\u003cp\u003eAnother rarely useful join is the \u003ccode\u003eCROSS JOIN\u003c/code\u003e. This gives the \u003cem\u003eCartesian product\u003c/em\u003e of the two tables which can be enormous. A Cartesian product would be every row matched with every other row in the other table. If you have A, B, and C in one table with D and E in the other, your CROSS JOIN would be AD, AE, BD, BE, CD, an CE. If you do a cross join between two tables with 1,000 rows each, you\u0026#39;d get 1,000,000 records back.\u003c/p\u003e\n\u003cp\u003eTables can also be self-joined. Imagine you have a table of employees and one of the fields is direct_reports which contains employee_ids of employees that report the original employee. You could do a SELF JOIN to get the information for the reports.\u003c/p\u003e\n\u003cp\u003eHonestly 95% of what I do is covered by INNER and LEFT joins.\u003c/p\u003e\n\u003cp\u003eOne neat trick we could do here is a NATURAL JOIN.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-sql\"\u003e\u003cspan class=\"hljs-keyword\"\u003eSELECT\u003c/span\u003e\n  comment_id, comments.user_id, users.username, \u003cspan class=\"hljs-type\"\u003etime\u003c/span\u003e, \u003cspan class=\"hljs-keyword\"\u003eLEFT\u003c/span\u003e(comment, \u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003eAS\u003c/span\u003e preview\n\u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e\n  comments\n\u003cspan class=\"hljs-keyword\"\u003eNATURAL\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eINNER\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eJOIN\u003c/span\u003e\n  users\n\u003cspan class=\"hljs-keyword\"\u003eWHERE\u003c/span\u003e\n  board_id \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e39\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis will work like it did above. NATURAL JOIN tells PostgreSQL \u0026quot;I named things the same in both tables, go ahead and match it together yourself. This is fun when it lines up but I don\u0026#39;t often end up using it myself. And in the end it\u0026#39;s often better to be explicit what about your intent is for joins. So use cautiously and/or for neat party tricks.\u003c/p\u003e\n\u003ch2\u003eSubqueries\u003c/h2\u003e\n\u003cp\u003eLet\u0026#39;s say you need to find all the comments made by Maynord Simonich. You could make two queries: query for Kate\u0026#39;s user_id from users, and then use that user_id to query comments. Or we could do it all at once with a subquery!\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-sql\"\u003e\u003cspan class=\"hljs-keyword\"\u003eSELECT\u003c/span\u003e comment_id, user_id, \u003cspan class=\"hljs-keyword\"\u003eLEFT\u003c/span\u003e(comment, \u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e comments \u003cspan class=\"hljs-keyword\"\u003eWHERE\u003c/span\u003e user_id \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003eSELECT\u003c/span\u003e user_id \u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e users \u003cspan class=\"hljs-keyword\"\u003eWHERE\u003c/span\u003e full_name \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;Maynord Simonich\u0026#x27;\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis will query for Maynord\u0026#39;s ID and immediately use that in the other query. Make sure this returns exactly one row or this will fail. You can use subqueries in a variety of ways but it generally looks like this with \u003ccode\u003e()\u003c/code\u003e surrounding the subqueries. You can even have subqueries in your subqueries!\u003c/p\u003e\n\u003ch2\u003eGROUP BY\u003c/h2\u003e\n\u003cp\u003eWhat if you were making a report and you wanted to show the top ten most posted-to message boards? You could run something like this.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-sql\"\u003e\u003cspan class=\"hljs-keyword\"\u003eSELECT\u003c/span\u003e\n  boards.board_name, \u003cspan class=\"hljs-built_in\"\u003eCOUNT\u003c/span\u003e(\u003cspan class=\"hljs-operator\"\u003e*\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003eAS\u003c/span\u003e comment_count\n\u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e\n  comments\n\u003cspan class=\"hljs-keyword\"\u003eINNER\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eJOIN\u003c/span\u003e\n  boards\n\u003cspan class=\"hljs-keyword\"\u003eON\u003c/span\u003e\n  boards.board_id \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e comments.board_id\n\u003cspan class=\"hljs-keyword\"\u003eGROUP\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eBY\u003c/span\u003e\n  boards.board_name\n\u003cspan class=\"hljs-keyword\"\u003eORDER\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eBY\u003c/span\u003e\n  comment_count \u003cspan class=\"hljs-keyword\"\u003eDESC\u003c/span\u003e\nLIMIT \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003ccode\u003eGROUP BY\u003c/code\u003e is going to collapse all the same board_names (guaranteed unique due to our UNIQUE constraint on the board) and then we use the \u003ccode\u003eCOUNT(*)\u003c/code\u003e to count how many boards have that same \u003ccode\u003eboard_name\u003c/code\u003e. So this works! This will give us the precise number of comments on the top board!\u003c/p\u003e\n\u003cp\u003eNow what if you wanted to see the boards that were the least populated? We could just flip the \u003ccode\u003eORDER BY\u003c/code\u003e to \u003ccode\u003eASC\u003c/code\u003e but there\u0026#39;s a distinct problem here: what happens if there\u0026#39;s no post on a board?\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-sql\"\u003e\u003cspan class=\"hljs-keyword\"\u003eSELECT\u003c/span\u003e\n  boards.board_name, \u003cspan class=\"hljs-built_in\"\u003eCOUNT\u003c/span\u003e(\u003cspan class=\"hljs-operator\"\u003e*\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003eAS\u003c/span\u003e comment_count\n\u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e\n  comments\n\u003cspan class=\"hljs-keyword\"\u003eINNER\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eJOIN\u003c/span\u003e\n  boards\n\u003cspan class=\"hljs-keyword\"\u003eON\u003c/span\u003e\n  boards.board_id \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e comments.board_id\n\u003cspan class=\"hljs-keyword\"\u003eGROUP\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eBY\u003c/span\u003e\n  boards.board_name\n\u003cspan class=\"hljs-keyword\"\u003eORDER\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eBY\u003c/span\u003e\n  comment_count \u003cspan class=\"hljs-keyword\"\u003eASC\u003c/span\u003e\nLIMIT \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIt wouldn\u0026#39;t show up because of the \u003ccode\u003eINNER JOIN\u003c/code\u003e. So what do we need? Well, the \u0026quot;LEFT\u0026quot; board here is the comments (the one that\u0026#39;s in the FROM will be LEFT) and we don\u0026#39;t need anything more from the comments board since all of them will show up in the query thanks to the foreign key constraints. So then we need a RIGHT JOIN! We need to include boards that don\u0026#39;t have any comments. We also need to change \u003ccode\u003eCOUNT(*)\u003c/code\u003e because any row counts for a \u003ccode\u003e*\u003c/code\u003e and that would make it look like there was one comment on our empty boards when in reality there was zero. We need therefore it to be \u003ccode\u003eCOUNT(comment_id)\u003c/code\u003e because that will actually count how many comments exist.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-sql\"\u003e\u003cspan class=\"hljs-keyword\"\u003eSELECT\u003c/span\u003e\n  boards.board_name, \u003cspan class=\"hljs-built_in\"\u003eCOUNT\u003c/span\u003e(comment_id) \u003cspan class=\"hljs-keyword\"\u003eAS\u003c/span\u003e comment_count\n\u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e\n  comments\n\u003cspan class=\"hljs-keyword\"\u003eRIGHT\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eJOIN\u003c/span\u003e\n  boards\n\u003cspan class=\"hljs-keyword\"\u003eON\u003c/span\u003e\n  boards.board_id \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e comments.board_id\n\u003cspan class=\"hljs-keyword\"\u003eGROUP\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eBY\u003c/span\u003e\n  boards.board_name\n\u003cspan class=\"hljs-keyword\"\u003eORDER\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eBY\u003c/span\u003e\n  comment_count;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eTricky! It\u0026#39;s important to know your data, what you expect to see, and be aware of the constraints of your queries!\u003c/p\u003e\n","markdown":"\nLet's get into some more complicated querying. First thing we're going to need is two more tables, comments and boards. We'll be making the data structure for a very simple message board system that has users, comments, and boards. The interesting part here is that every comment is posted by a user and therefore will need to reference the user table, and it will be posted to board and therefore will need to reference a board from the boards table. This is what you would call relational data and where relational databases really shine.\n\n## Foreign Keys\n\nLet's jot down all of our schemas for our users, boards, and comments.\n\n```sql\n\nCREATE TABLE users (\n  user_id INTEGER PRIMARY KEY GENERATED ALWAYS AS IDENTITY,\n  username VARCHAR ( 25 ) UNIQUE NOT NULL,\n  email VARCHAR ( 50 ) UNIQUE NOT NULL,\n  full_name VARCHAR ( 100 ) NOT NULL,\n  last_login TIMESTAMP,\n  created_on TIMESTAMP NOT NULL\n);\n\nCREATE TABLE boards (\n  board_id INTEGER PRIMARY KEY GENERATED ALWAYS AS IDENTITY,\n  board_name VARCHAR ( 50 ) UNIQUE NOT NULL,\n  board_description TEXT NOT NULL\n);\n\nCREATE TABLE comments (\n  comment_id INTEGER PRIMARY KEY GENERATED ALWAYS AS IDENTITY,\n  user_id INT REFERENCES users(user_id) ON DELETE CASCADE,\n  board_id INT REFERENCES boards(board_id) ON DELETE CASCADE,\n  comment TEXT NOT NULL,\n  time TIMESTAMP\n);\n\n```\n\n- The first two should look pretty familiar. The only new-ish thing is the user of the `TEXT` data type. This is basically a VARCHAR with no cap (or rather a very large cap.) It has some other small differences but for now just know it's uncapped text.\n- `user_id INT REFERENCES users(user_id)` is technically all you need to make a foreign key. The first part, `INT`, makes it known that this key will be stored as an integer. It then uses the `REFERENCES` key word to let PostgreSQL know that it is a foreign key. A foreign key is a field in one table that references the **primary** key of another table. In this case, a comment will reference the user_id in another table, the users table. The `users` part say it's reference the users table and the `(user_id)` is the name of the key in the other table. In this case, we called both user_id (which will probably happen somewhat frequently but not always) so they match but if we had called the user_id just id in the users table, we'd put `id` there.\n- `ON DELETE CASCADE` lets PostgreSQL know what to do if the user gets deleted. So if a user makes a comment on the message board and then deletes their account, what do you want it to do? If you omit the `ON DELETE CASCADE` part, it's the same as doing `ON DELETE NO ACTION` which means it'll just error and not let you delete the user until you've deleted all the comments first. You can also do `ON DELETE SET NULL` which means it'll make the user_id null on any comment that was made by that user.\n- We've dne the same for board_id, just referencing the boards table instead of the users table.\n\nLet's go ahead and put some dummy data in there. Copy / paste [this query] into your psql terminal. It may take a few minutes.\n\n## JOIN\n\nSo a user goes to your message board and click\n\n```sql\nSELECT comment_id, user_id, LEFT(comment, 20) AS preview FROM comments WHERE board_id = 39;\n```\n\n- Two new things here. The `LEFT` function will return the first X characters of a string (as you can guess, RIGHT returns the last X charcters). We'r doing this because this hard to read otherwise in the command line.\n- The `AS` keyword lets you rename how the string is projected. If we don't use AS here, the string will be returned under they key `left` which doesn't make sense.\n\nOkay so you'll get something back like this:\n\n```\n comment_id | user_id |       preview\n------------+---------+----------------------\n         63 |     858 | Maecenas tristique,\n        358 |     876 | Mauris enim leo, rho\n        429 |     789 | Maecenas ut massa qu\n        463 |     925 | Phasellus sit amet e\n        485 |     112 | Maecenas tristique,\n        540 |     588 | Nullam porttitor lac\n        545 |     587 | Praesent id massa id\n        972 |     998 | Aenean lectus. Pelle\n(8 rows)\n```\n\nWe can't really use this to display the comments on our web app because your users don't care what user_id posted these comments, they want the username. But that doesn't live in the comments table, that exists in the users table. So how do we connect those together?\n\n```sql\nSELECT\n  comment_id, comments.user_id, users.username, time, LEFT(comment, 20) AS preview\nFROM\n  comments\nINNER JOIN\n  users\nON\n  comments.user_id = users.user_id\nWHERE\n  board_id = 39;\n```\n\nMagic! The big key here is the `INNER JOIN` which allows us to match up all the keys from one table to another. We do that in `ON` clause where we say user*ids match is where you can \\_join* together those records into one record.\n\nLet's talk about `INNER` for a second. There are multiple kinds of JOINs. INNER is a good one start with. It says \"find where user_ids match. If you find a record where the user_id exists in one but not in the other, omit it in the results.\" This isn't a particularly useful distinction for us right now becase all user_ids will exist in users and we're assured of that due to the foreign key restraints we used. However if a comment had a user_id that didn't exist, it would omit that comment in the results.\n\n[![diagram of SQL joins](./images/SQL_Joins.png)](https://commons.wikimedia.org/wiki/File:SQL_Joins.svg)\n\nA `LEFT JOIN` would say \"if a comment has a user_id that doesn't exist, include it anyway.\" A `RIGHT JOIN` wouldn't make much sense here but it would include users even if they didn't have a comment on that board.\n\nWe can also an `OUTER JOIN` which would be everything that _doesn't match_. In our database, that would be nothing because we're guaranteed everything has match due to our constraints.\n\nYou can also do a `FULL OUTER JOIN` which says just include everything. If it doesn't have a match from either side, include it. If it does have a match, include it.\n\nAnother rarely useful join is the `CROSS JOIN`. This gives the _Cartesian product_ of the two tables which can be enormous. A Cartesian product would be every row matched with every other row in the other table. If you have A, B, and C in one table with D and E in the other, your CROSS JOIN would be AD, AE, BD, BE, CD, an CE. If you do a cross join between two tables with 1,000 rows each, you'd get 1,000,000 records back.\n\nTables can also be self-joined. Imagine you have a table of employees and one of the fields is direct_reports which contains employee_ids of employees that report the original employee. You could do a SELF JOIN to get the information for the reports.\n\nHonestly 95% of what I do is covered by INNER and LEFT joins.\n\nOne neat trick we could do here is a NATURAL JOIN.\n\n```sql\nSELECT\n  comment_id, comments.user_id, users.username, time, LEFT(comment, 20) AS preview\nFROM\n  comments\nNATURAL INNER JOIN\n  users\nWHERE\n  board_id = 39;\n```\n\nThis will work like it did above. NATURAL JOIN tells PostgreSQL \"I named things the same in both tables, go ahead and match it together yourself. This is fun when it lines up but I don't often end up using it myself. And in the end it's often better to be explicit what about your intent is for joins. So use cautiously and/or for neat party tricks.\n\n## Subqueries\n\nLet's say you need to find all the comments made by Maynord Simonich. You could make two queries: query for Kate's user_id from users, and then use that user_id to query comments. Or we could do it all at once with a subquery!\n\n```sql\nSELECT comment_id, user_id, LEFT(comment, 20) FROM comments WHERE user_id = (SELECT user_id FROM users WHERE full_name = 'Maynord Simonich');\n```\n\nThis will query for Maynord's ID and immediately use that in the other query. Make sure this returns exactly one row or this will fail. You can use subqueries in a variety of ways but it generally looks like this with `()` surrounding the subqueries. You can even have subqueries in your subqueries!\n\n## GROUP BY\n\nWhat if you were making a report and you wanted to show the top ten most posted-to message boards? You could run something like this.\n\n```sql\nSELECT\n  boards.board_name, COUNT(*) AS comment_count\nFROM\n  comments\nINNER JOIN\n  boards\nON\n  boards.board_id = comments.board_id\nGROUP BY\n  boards.board_name\nORDER BY\n  comment_count DESC\nLIMIT 10;\n```\n\n`GROUP BY` is going to collapse all the same board_names (guaranteed unique due to our UNIQUE constraint on the board) and then we use the `COUNT(*)` to count how many boards have that same `board_name`. So this works! This will give us the precise number of comments on the top board!\n\nNow what if you wanted to see the boards that were the least populated? We could just flip the `ORDER BY` to `ASC` but there's a distinct problem here: what happens if there's no post on a board?\n\n```sql\nSELECT\n  boards.board_name, COUNT(*) AS comment_count\nFROM\n  comments\nINNER JOIN\n  boards\nON\n  boards.board_id = comments.board_id\nGROUP BY\n  boards.board_name\nORDER BY\n  comment_count ASC\nLIMIT 10;\n```\n\nIt wouldn't show up because of the `INNER JOIN`. So what do we need? Well, the \"LEFT\" board here is the comments (the one that's in the FROM will be LEFT) and we don't need anything more from the comments board since all of them will show up in the query thanks to the foreign key constraints. So then we need a RIGHT JOIN! We need to include boards that don't have any comments. We also need to change `COUNT(*)` because any row counts for a `*` and that would make it look like there was one comment on our empty boards when in reality there was zero. We need therefore it to be `COUNT(comment_id)` because that will actually count how many comments exist.\n\n```sql\nSELECT\n  boards.board_name, COUNT(comment_id) AS comment_count\nFROM\n  comments\nRIGHT JOIN\n  boards\nON\n  boards.board_id = comments.board_id\nGROUP BY\n  boards.board_name\nORDER BY\n  comment_count;\n```\n\nTricky! It's important to know your data, what you expect to see, and be aware of the constraints of your queries!\n","slug":"complex-sql-queries","title":"Complex Sql Queries","section":"Sql","icon":"info-circle","filePath":"/home/runner/work/complete-intro-to-databases-v2/complete-intro-to-databases-v2/lessons/03-sql/D-complex-sql-queries.md","nextSlug":"/lessons/sql/json-in-postgresql","prevSlug":"/lessons/sql/querying-postgresql"}},"__N_SSG":true},"page":"/lessons/[section]/[slug]","query":{"section":"sql","slug":"complex-sql-queries"},"buildId":"Ogv8p-BwCHRQ1PzRpAU9u","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>