<!DOCTYPE html><html><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width" data-next-head=""/><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png" data-next-head=""/><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png" data-next-head=""/><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png" data-next-head=""/><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png" data-next-head=""/><link rel="icon" type="image/x-icon" href="/images/favicon.ico" data-next-head=""/><title data-next-head="">Conclusion – Complete Intro to Databases v2</title><meta name="description" content="Brian wraps up the course and says his parting, wise words." data-next-head=""/><meta name="keywords" content="postgres,sql,redis,mongodb,neo4j,database,data,agents" data-next-head=""/><meta name="og:description" content="Brian wraps up the course and says his parting, wise words." data-next-head=""/><meta name="og:title" content="Conclusion – Complete Intro to Databases v2" data-next-head=""/><meta name="og:image" content="/images/social-share-cover.jpg" data-next-head=""/><meta name="twitter:card" content="summary_large_image" data-next-head=""/><link data-next-font="size-adjust" rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/_next/static/chunks/3802a39ca373f962.css" as="style"/><link rel="stylesheet" href="/_next/static/chunks/3802a39ca373f962.css" data-n-g=""/><noscript data-n-css=""></noscript><script src="/_next/static/chunks/dbe15a90055bd265.js" defer=""></script><script src="/_next/static/chunks/49c75c2ed6206f46.js" defer=""></script><script src="/_next/static/chunks/da0ff8adaa6cce90.js" defer=""></script><script src="/_next/static/chunks/turbopack-342361b32f83e6b6.js" defer=""></script><script src="/_next/static/chunks/f189af6b04c7fd39.js" defer=""></script><script src="/_next/static/chunks/turbopack-8b35dea75ba6f85c.js" defer=""></script><script src="/_next/static/Ogv8p-BwCHRQ1PzRpAU9u/_ssgManifest.js" defer=""></script><script src="/_next/static/Ogv8p-BwCHRQ1PzRpAU9u/_buildManifest.js" defer=""></script></head><body><script async="" defer="" src="https://a.holt.courses/latest.js"></script><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"/><div id="__next"><link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&amp;display=swap" rel="stylesheet"/><div class="remix-app"><header class="navbar"><h1 class="navbar-brand"><a href="/">Complete Intro to Databases v2</a></h1><div class="navbar-info"><a href="https://frontendmasters.com/workshops/databases-v2/" class="cta-btn">Watch on Frontend Masters</a></div></header><div class="content-container"><div class="main"><div class="lesson-container"><div class="lesson"><div class="lesson-content"><p>Congratulations! You survived a tidal wave of information coming your way about how to store data in a variety different settings. You have enough context now to make a good judgment call on the best way to store you data n a variety of different settings and needs. Let&#39;s go over a few more considerations for you to make as you&#39;re considering decisions to choose when and where.</p>
<h2>Paradigm</h2>
<p>Having a decent amount of familiarity with the databases I&#39;ve shown you as well as a few others, the first thing I stop to think about with which database I want to use with a project is what paradigm of data do I have?</p>
<ul>
<li>Do I have highly relational data where I&#39;ll many tables that need to join to other tables? SQL/Relational databases are probably best here</li>
<li>Do I have highly unstructured data where I&#39;ll have collections of related objects that are differently shaped? Document-based databases are going to shine here</li>
<li>Do I have data where I need to describe graphs of relationships? A graph database can work best here</li>
<li>Do I have simple needs of just retreiving data based on keys? Key-value stores can be a primary database in these cases</li>
<li>Do I have pipelines of information that need to filter, split, combined, and republished? Something like <a href="https://kafka.apache.org/">Apache Kafka</a> could be really helpful here</li>
</ul>
<p>Do none, some, or all of these fit? Do you have other considerations? Take a second to consider all of your data needs.</p>
<h2>Read-Heavy vs Write-Heavy</h2>
<p>This has as much to do with <em>which database</em> you&#39;re choosing as it does with <em>how you architect</em> your data with whatever database you&#39;re choosing.</p>
<p>Here&#39;s a great example (shout to my conversation with [Harry Wolff], director at MongoDB Inc that inspired this.) If you have relational data but it&#39;s almost never read and more frequently read and your other usecases are more favored to using a document-based database, MongoDB is actually a fine choice to make in that case. MongoDB does do joins, it&#39;s just not so optimized as something like PostgreSQL is for it.</p>
<p>Think a lot about where your hotspots of reads and writes are. Optimize for those. You can tolerate slowness and inefficiency in areas where they don&#39;t get run frequently.</p>
<p>Also recognize that you can rarely anticipate fully where your hotspots and non-hotspots are going to be in advance so be flexible.</p>
<h2>Familiarity</h2>
<p>People don&#39;t put enough weight into familiarity. We think as developer we can pick anything at the drop of a hat and that just isn&#39;t true. Learning new tech is expensive, both from a time perspective and from you&#39;re-going-to-cause-downtime-because-you-don&#39;t-know-all-the-problems perspective. I remember at Reddit we went with MySQL despite PostgreSQL being all the hotness at the time because the entire team had familiarity with MySQL and no one knew PostgreSQL at all. Be sure to properly weigh experience into your decision. Some knowledge is only won through experience.</p>
<h2>Quality of Drivers</h2>
<p>Be sure to be poke around the SDKs / drivers of whatever database you may choose with the language you&#39;re going to use. If MongoDB is amazing but their Elixir SDK is nonexistant or bad (I have no idea if it, just making an example) then no matter how good the database is you&#39;re still going to be fighting the SDK. Do the homework here and you&#39;ll save yourself some pain.</p>
<h2>Ops Cost</h2>
<p>Databases frequently end up being the most expensive part of your app from all perspectives: raw cost, raw time spent writing code for it, and cost of eventual downtime. Take a look at it from the perspective of how much it&#39;s going to cost you to hire ops people that know how to run this particular server in production.</p>
<p>In this capacity, and very biasedly, I recommend you look into using a cloud-based database. While the monetary cost of paying for a managed database-as-a-service is higher than just running a few VMs, not having to manage sharding, clusters, peering, elections, networking, firewalls, software updates, operating system updates, capacity allocations, horizontal scaling, vertical scaling, etc. frequently can make it more-than worth the cost. Again, I&#39;m biased here due to my current employment at Microsoft Azure, but this is what I would choose even I wasn&#39;t employed here. All major cloud providers have great options here.</p>
<h2>Be Boring</h2>
<p>I can&#39;t stress this enough. With your core infrastructure (a.k.a. anything that if it went down your app would go down) be as boring as you can tolerate. Instead of choosing what&#39;s hot, what&#39;s on Hacker News, what&#39;s being talked about on Twitter, what people are talking about at conferences, etc. just choose boring, tried-and-true technologies. Everything I&#39;ve shown you here I think is mature enough to be considered boring. But make it boring to you by using them, finding problems, breaking them, and trying new things with them. Then they&#39;ll be boring for you too.</p>
<p>If you&#39;re going to do something exciting, have a damn good reason why it&#39;s much better than a boring alternative. On the bleeding edge, you&#39;re the one who is bleeding.</p>
<h2>Caching</h2>
<p>We went over caching a bit but I wanted to say a few things about it.</p>
<p>Caching is a very, very hard problem and causes a lot of problems. Make sure you <em>need</em> caching before you just throw it in there. Don&#39;t assume you need caching. Need caching before you put it in. It&#39;s hard to know when to cache, how to long to cache, when to invalidate caches, when not to, etc. It&#39;s just hard and make sure you need it.</p>
<p>Caching is frequently a band-aid on a worse problem. Instead of fixing inefficiencies in a system that would obviate the need for caching people just throw a cache in front of something and ignore the problems in their systems. This often leads to bigger problems. Again, validate the need for caching and ask the question &quot;if I just improved the performance of this system would I still need caching?&quot;</p>
<p>A big reason I throw out so much caution for caching is that databases are built to handle a lot of load and if you use them with best practices you can get a lot of performance out of them. Problems often arise because we&#39;re not using the tools correctly (like writing bad queries or having something misconfigured) and if we can fix these we can achieve greater scale without the need for a cache.</p>
<p>Caching just adds so much indirection to your app. Now you whenever your API isn&#39;t responding correctly, you have to ask yourself &quot;is this a stale cache?&quot; God forbid you have multiple layers of caching (maybe you cache the database response, the external API response, and then cache the API response before it goes out) then you need to pick apart which cache was stale or if it&#39;s an underlying problem. It&#39;s also hard to avoid thundering herd problems. I taught you caching for a reason because sometimes we just do need it but it&#39;s a sharp implement; make sure you only use it when you actually need it and keep it as simple as you can.</p>
<h2>Next Courses to Take</h2>
<p>Frontend Masters has so many wonderful courses and instructors to offer. Here a handful of ones that I&#39;d recommend after taking this one if you want to further deepen skills</p>
<h3>From me, Brian Holt</h3>
<ul>
<li>I want to get better at the command line: <a href="https://frontendmasters.com/courses/linux-command-line/">Complete Intro to Linux and the CLI</a></li>
<li>I want to learn about the containers we&#39;ve been using this whole time: <a href="https://frontendmasters.com/courses/complete-intro-containers/">Complete Intro to Containers</a></li>
</ul>
<h3>From other amazing instructors</h3>
<ul>
<li>I want to get better at MongoDB from Scott Moss<ul>
<li><a href="https://frontendmasters.com/courses/mongodb/">Intro to MongoDB (including Mongoose ORM)</a></li>
<li><a href="https://frontendmasters.com/courses/api-design-nodejs-v3/">API Design with MongoDB</a></li>
</ul>
</li>
<li>I want to get better at GraphQL from Scott Moss<ul>
<li><a href="https://frontendmasters.com/courses/server-graphql-nodejs/">From the server</a></li>
<li><a href="https://frontendmasters.com/courses/client-graphql-react/">From the client</a></li>
<li><a href="https://frontendmasters.com/courses/advanced-graphql-v2/">Advance GraphQL</a></li>
</ul>
</li>
<li><a href="https://frontendmasters.com/courses/fullstack-v2/">I want to get better at managing servers and cloud deployments</a> from Jem Young</li>
</ul>
<h2>Wrap Up</h2>
<p>Thank you for sticking through this tutorial and congrats on your unlocked achievement of understanding databases! Be sure tweet at me your success <a href="https://twitter.com/holtbt">here</a>. And if you found issues, particularly with grammar, <a href="https://github.com/btholt/complete-intro-to-databases">open a pull request!</a></p>
<p>I hope you enjoyed the course!</p>
</div><div class="lesson-links"><a class="prev" href="/lessons/key-value-store/redis-ops">← Previous</a></div></div><div class="details-bg"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="154" height="154" viewBox="0 0 154 154"><defs><clipPath id="clip-path"><rect id="Rectangle_2238" data-name="Rectangle 2238" width="154" height="154" transform="translate(9467 350)" fill="#fff" stroke="#707070" stroke-width="1"></rect></clipPath><clipPath id="clip-corner-image-active"><rect width="154" height="154"></rect></clipPath></defs><g id="corner-image-active" clip-path="url(#clip-corner-image-active)"><g id="Corner-image-active-2" data-name="Corner-image-active" transform="translate(-9467 -350)" clip-path="url(#clip-path)"><path id="Subtraction_34" data-name="Subtraction 34" d="M-3857.365,1740.766h0l-7.07-7.07,12.89-12.89v14.142l-5.818,5.818Zm-14.142-14.142h0l-7.071-7.07,27.033-27.033v14.143l-19.96,19.96Zm-14.143-14.143h0l-7.07-7.069,41.175-41.175v14.142Zm-14.142-14.142h0l-7.07-7.069,55.317-55.317v14.142Zm-14.142-14.142h0l-7.07-7.069,69.459-69.459v14.142Zm-14.142-14.142h0l-7.07-7.069,76.739-76.739h6.862v7.28Zm-14.143-14.143h0l-7.07-7.069,62.6-62.6h14.142Zm-14.142-14.142h0l-7.07-7.069,48.454-48.454h14.142Zm-14.142-14.142h0l-7.07-7.069,34.312-34.312h14.142Zm-14.142-14.142h0l-7.07-7.069,20.17-20.17h14.142Zm-14.142-14.142h0l-7.071-7.071,6.027-6.027h14.144l-13.1,13.1Zm367.24-56.114v-.909l.455.455-.453.453Z" transform="translate(13472.546 -1236.766)" fill="var(--corner-fill)"></path></g></g></svg></div></div></div></div><footer class="footer"><ul class="socials"><li class="social"><a href="https://twitter.com/holtbt"><svg fill="none" height="100%" width="32" xmlns="http://www.w3.org/2000/svg" viewBox="0.254 0.25 500 451.95400000000006"><path d="M394.033.25h76.67L303.202 191.693l197.052 260.511h-154.29L225.118 294.205 86.844 452.204H10.127l179.16-204.77L.254.25H158.46l109.234 144.417zm-26.908 406.063h42.483L135.377 43.73h-45.59z" fill="var(--footer-icons)"></path></svg></a></li><li class="social"><a href="https://bsky.app/profile/brianholt.me"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 -3.268 64 68.414" width="38" height="100%"><path fill="var(--footer-icons)" d="M13.873 3.805C21.21 9.332 29.103 20.537 32 26.55v15.882c0-.338-.13.044-.41.867-1.512 4.456-7.418 21.847-20.923 7.944-7.111-7.32-3.819-14.64 9.125-16.85-7.405 1.264-15.73-.825-18.014-9.015C1.12 23.022 0 8.51 0 6.55 0-3.268 8.579-.182 13.873 3.805zm36.254 0C42.79 9.332 34.897 20.537 32 26.55v15.882c0-.338.13.044.41.867 1.512 4.456 7.418 21.847 20.923 7.944 7.111-7.32 3.819-14.64-9.125-16.85 7.405 1.264 15.73-.825 18.014-9.015C62.88 23.022 64 8.51 64 6.55c0-9.818-8.578-6.732-13.873-2.745z"></path></svg></a></li><li class="social"><a href="https://github.com/btholt"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="32" height="32" viewBox="0 0 32 32"><defs><clipPath id="clip-github-social"><rect width="32" height="32"></rect></clipPath></defs><g id="github-social" clip-path="url(#clip-github-social)"><g id="Group_272" data-name="Group 272" transform="translate(13522.5 -6994)"><path id="Subtraction_33" data-name="Subtraction 33" d="M-24967.5,8041a15.9,15.9,0,0,1-11.312-4.688A15.893,15.893,0,0,1-24983.5,8025a15.893,15.893,0,0,1,4.689-11.315A15.894,15.894,0,0,1-24967.5,8009a15.894,15.894,0,0,1,11.313,4.686A15.893,15.893,0,0,1-24951.5,8025a15.893,15.893,0,0,1-4.689,11.313A15.9,15.9,0,0,1-24967.5,8041Zm-3.781-4.571h0v3.918h7.895v-6.665a1.836,1.836,0,0,0-1.2-1.718c5.1-.617,7.467-2.975,7.467-7.424a7.176,7.176,0,0,0-1.637-4.728,6.74,6.74,0,0,0,.275-1.812,4.34,4.34,0,0,0-.52-2.452.574.574,0,0,0-.359-.1c-1.061,0-3.465,1.411-3.936,1.694a16.644,16.644,0,0,0-4.2-.489,16.379,16.379,0,0,0-3.969.445c-.846-.5-2.91-1.649-3.859-1.649a.566.566,0,0,0-.354.095,4.3,4.3,0,0,0-.521,2.452,6.7,6.7,0,0,0,.244,1.718,7.346,7.346,0,0,0-1.6,4.822,7.263,7.263,0,0,0,1.533,4.985c1.193,1.359,3.115,2.165,5.871,2.464a1.826,1.826,0,0,0-1.129,1.693v.5h0l-.006,0a7.121,7.121,0,0,1-2.033.363,2.608,2.608,0,0,1-.965-.158,4.438,4.438,0,0,1-1.836-1.881,2.361,2.361,0,0,0-1.248-1.091,3.472,3.472,0,0,0-1.217-.3.584.584,0,0,0-.545.224.282.282,0,0,0,.027.367,1.875,1.875,0,0,0,.447.307,4.732,4.732,0,0,1,.561.355,10.726,10.726,0,0,1,1.682,2.755c.043.092.078.163.105.217a3.876,3.876,0,0,0,2.42,1.185,6.036,6.036,0,0,0,.607.025c.875,0,1.988-.124,2-.125Z" transform="translate(11461 -1015)" fill="var(--footer-icons)"></path><g id="Ellipse_670" data-name="Ellipse 670" transform="translate(-13522.5 6994)" fill="none" stroke="var(--footer-icons)" stroke-width="1"><circle cx="16" cy="16" r="16" stroke="none"></circle><circle cx="16" cy="16" r="15.5" fill="none"></circle></g></g></g></svg></a></li><li class="social"><a href="https://linkedin.com/in/btholt"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="32" height="32" viewBox="0 0 32 32"><defs><clipPath id="clip-linkedin-social"><rect width="32" height="32"></rect></clipPath></defs><g id="linkedin-social" clip-path="url(#clip-linkedin-social)"><g id="Group_270" data-name="Group 270" transform="translate(-86.349 -633.073)"><path id="Path_375" data-name="Path 375" d="M115.789,633.073a2.324,2.324,0,0,1,1.682.676,2.194,2.194,0,0,1,.695,1.627V662.8a2.131,2.131,0,0,1-.695,1.609,2.314,2.314,0,0,1-1.646.659H88.69a2.307,2.307,0,0,1-1.646-.659,2.128,2.128,0,0,1-.695-1.609V635.376a2.19,2.19,0,0,1,.695-1.627,2.322,2.322,0,0,1,1.682-.676h27.063Zm-20.224,9.672a2.561,2.561,0,0,0,0-3.584,2.658,2.658,0,0,0-1.938-.712,2.724,2.724,0,0,0-1.957.712,2.371,2.371,0,0,0-.75,1.792,2.4,2.4,0,0,0,.731,1.792,2.605,2.605,0,0,0,1.9.713h.037A2.7,2.7,0,0,0,95.565,642.745ZM96,645.434H91.213V659.88H96Zm17.3,6.144a7.007,7.007,0,0,0-1.573-4.9,5.68,5.68,0,0,0-6.839-.769,5.663,5.663,0,0,0-1.426,1.573v-2.048H98.674q.036.841,0,7.717v6.728h4.791V651.8a3.592,3.592,0,0,1,.146-1.17,2.913,2.913,0,0,1,.878-1.206,2.429,2.429,0,0,1,1.609-.549,2.108,2.108,0,0,1,1.865.914,4.265,4.265,0,0,1,.549,2.341v7.752H113.3Z" fill="var(--footer-icons)"></path></g></g></svg></a></li><li class="social"><div class="terms"><p>Content Licensed Under CC-BY-NC-4.0</p><p>Code Samples and Exercises Licensed Under Apache 2.0</p><p>Site Designed by<!-- --> <a href="https://www.alexdanielson.com/">Alex Danielson</a></p></div></li></ul><div class="theme-icons"><button aria-label="Activate dark mode" title="Activate dark mode" class="theme-toggle"><svg xmlns="http://www.w3.org/2000/svg" width="36px" height="100%" viewBox="0 -960 960 960" fill="var(--text-footer)" role="img"><title>Dark Mode Icon</title><path d="M480-120q-150 0-255-105T120-480q0-150 105-255t255-105q14 0 27.5 1t26.5 3q-41 29-65.5 75.5T444-660q0 90 63 153t153 63q55 0 101-24.5t75-65.5q2 13 3 26.5t1 27.5q0 150-105 255T480-120Zm0-80q88 0 158-48.5T740-375q-20 5-40 8t-40 3q-123 0-209.5-86.5T364-660q0-20 3-40t8-40q-78 32-126.5 102T200-480q0 116 82 198t198 82Z"></path></svg></button></div></footer></div><noscript><img src="https://a.holt.courses/noscript.gif" alt="" referrerPolicy="no-referrer-when-downgrade"/></noscript></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"attributes":{"description":"Brian wraps up the course and says his parting, wise words."},"html":"\u003cp\u003eCongratulations! You survived a tidal wave of information coming your way about how to store data in a variety different settings. You have enough context now to make a good judgment call on the best way to store you data n a variety of different settings and needs. Let\u0026#39;s go over a few more considerations for you to make as you\u0026#39;re considering decisions to choose when and where.\u003c/p\u003e\n\u003ch2\u003eParadigm\u003c/h2\u003e\n\u003cp\u003eHaving a decent amount of familiarity with the databases I\u0026#39;ve shown you as well as a few others, the first thing I stop to think about with which database I want to use with a project is what paradigm of data do I have?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDo I have highly relational data where I\u0026#39;ll many tables that need to join to other tables? SQL/Relational databases are probably best here\u003c/li\u003e\n\u003cli\u003eDo I have highly unstructured data where I\u0026#39;ll have collections of related objects that are differently shaped? Document-based databases are going to shine here\u003c/li\u003e\n\u003cli\u003eDo I have data where I need to describe graphs of relationships? A graph database can work best here\u003c/li\u003e\n\u003cli\u003eDo I have simple needs of just retreiving data based on keys? Key-value stores can be a primary database in these cases\u003c/li\u003e\n\u003cli\u003eDo I have pipelines of information that need to filter, split, combined, and republished? Something like \u003ca href=\"https://kafka.apache.org/\"\u003eApache Kafka\u003c/a\u003e could be really helpful here\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eDo none, some, or all of these fit? Do you have other considerations? Take a second to consider all of your data needs.\u003c/p\u003e\n\u003ch2\u003eRead-Heavy vs Write-Heavy\u003c/h2\u003e\n\u003cp\u003eThis has as much to do with \u003cem\u003ewhich database\u003c/em\u003e you\u0026#39;re choosing as it does with \u003cem\u003ehow you architect\u003c/em\u003e your data with whatever database you\u0026#39;re choosing.\u003c/p\u003e\n\u003cp\u003eHere\u0026#39;s a great example (shout to my conversation with [Harry Wolff], director at MongoDB Inc that inspired this.) If you have relational data but it\u0026#39;s almost never read and more frequently read and your other usecases are more favored to using a document-based database, MongoDB is actually a fine choice to make in that case. MongoDB does do joins, it\u0026#39;s just not so optimized as something like PostgreSQL is for it.\u003c/p\u003e\n\u003cp\u003eThink a lot about where your hotspots of reads and writes are. Optimize for those. You can tolerate slowness and inefficiency in areas where they don\u0026#39;t get run frequently.\u003c/p\u003e\n\u003cp\u003eAlso recognize that you can rarely anticipate fully where your hotspots and non-hotspots are going to be in advance so be flexible.\u003c/p\u003e\n\u003ch2\u003eFamiliarity\u003c/h2\u003e\n\u003cp\u003ePeople don\u0026#39;t put enough weight into familiarity. We think as developer we can pick anything at the drop of a hat and that just isn\u0026#39;t true. Learning new tech is expensive, both from a time perspective and from you\u0026#39;re-going-to-cause-downtime-because-you-don\u0026#39;t-know-all-the-problems perspective. I remember at Reddit we went with MySQL despite PostgreSQL being all the hotness at the time because the entire team had familiarity with MySQL and no one knew PostgreSQL at all. Be sure to properly weigh experience into your decision. Some knowledge is only won through experience.\u003c/p\u003e\n\u003ch2\u003eQuality of Drivers\u003c/h2\u003e\n\u003cp\u003eBe sure to be poke around the SDKs / drivers of whatever database you may choose with the language you\u0026#39;re going to use. If MongoDB is amazing but their Elixir SDK is nonexistant or bad (I have no idea if it, just making an example) then no matter how good the database is you\u0026#39;re still going to be fighting the SDK. Do the homework here and you\u0026#39;ll save yourself some pain.\u003c/p\u003e\n\u003ch2\u003eOps Cost\u003c/h2\u003e\n\u003cp\u003eDatabases frequently end up being the most expensive part of your app from all perspectives: raw cost, raw time spent writing code for it, and cost of eventual downtime. Take a look at it from the perspective of how much it\u0026#39;s going to cost you to hire ops people that know how to run this particular server in production.\u003c/p\u003e\n\u003cp\u003eIn this capacity, and very biasedly, I recommend you look into using a cloud-based database. While the monetary cost of paying for a managed database-as-a-service is higher than just running a few VMs, not having to manage sharding, clusters, peering, elections, networking, firewalls, software updates, operating system updates, capacity allocations, horizontal scaling, vertical scaling, etc. frequently can make it more-than worth the cost. Again, I\u0026#39;m biased here due to my current employment at Microsoft Azure, but this is what I would choose even I wasn\u0026#39;t employed here. All major cloud providers have great options here.\u003c/p\u003e\n\u003ch2\u003eBe Boring\u003c/h2\u003e\n\u003cp\u003eI can\u0026#39;t stress this enough. With your core infrastructure (a.k.a. anything that if it went down your app would go down) be as boring as you can tolerate. Instead of choosing what\u0026#39;s hot, what\u0026#39;s on Hacker News, what\u0026#39;s being talked about on Twitter, what people are talking about at conferences, etc. just choose boring, tried-and-true technologies. Everything I\u0026#39;ve shown you here I think is mature enough to be considered boring. But make it boring to you by using them, finding problems, breaking them, and trying new things with them. Then they\u0026#39;ll be boring for you too.\u003c/p\u003e\n\u003cp\u003eIf you\u0026#39;re going to do something exciting, have a damn good reason why it\u0026#39;s much better than a boring alternative. On the bleeding edge, you\u0026#39;re the one who is bleeding.\u003c/p\u003e\n\u003ch2\u003eCaching\u003c/h2\u003e\n\u003cp\u003eWe went over caching a bit but I wanted to say a few things about it.\u003c/p\u003e\n\u003cp\u003eCaching is a very, very hard problem and causes a lot of problems. Make sure you \u003cem\u003eneed\u003c/em\u003e caching before you just throw it in there. Don\u0026#39;t assume you need caching. Need caching before you put it in. It\u0026#39;s hard to know when to cache, how to long to cache, when to invalidate caches, when not to, etc. It\u0026#39;s just hard and make sure you need it.\u003c/p\u003e\n\u003cp\u003eCaching is frequently a band-aid on a worse problem. Instead of fixing inefficiencies in a system that would obviate the need for caching people just throw a cache in front of something and ignore the problems in their systems. This often leads to bigger problems. Again, validate the need for caching and ask the question \u0026quot;if I just improved the performance of this system would I still need caching?\u0026quot;\u003c/p\u003e\n\u003cp\u003eA big reason I throw out so much caution for caching is that databases are built to handle a lot of load and if you use them with best practices you can get a lot of performance out of them. Problems often arise because we\u0026#39;re not using the tools correctly (like writing bad queries or having something misconfigured) and if we can fix these we can achieve greater scale without the need for a cache.\u003c/p\u003e\n\u003cp\u003eCaching just adds so much indirection to your app. Now you whenever your API isn\u0026#39;t responding correctly, you have to ask yourself \u0026quot;is this a stale cache?\u0026quot; God forbid you have multiple layers of caching (maybe you cache the database response, the external API response, and then cache the API response before it goes out) then you need to pick apart which cache was stale or if it\u0026#39;s an underlying problem. It\u0026#39;s also hard to avoid thundering herd problems. I taught you caching for a reason because sometimes we just do need it but it\u0026#39;s a sharp implement; make sure you only use it when you actually need it and keep it as simple as you can.\u003c/p\u003e\n\u003ch2\u003eNext Courses to Take\u003c/h2\u003e\n\u003cp\u003eFrontend Masters has so many wonderful courses and instructors to offer. Here a handful of ones that I\u0026#39;d recommend after taking this one if you want to further deepen skills\u003c/p\u003e\n\u003ch3\u003eFrom me, Brian Holt\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eI want to get better at the command line: \u003ca href=\"https://frontendmasters.com/courses/linux-command-line/\"\u003eComplete Intro to Linux and the CLI\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eI want to learn about the containers we\u0026#39;ve been using this whole time: \u003ca href=\"https://frontendmasters.com/courses/complete-intro-containers/\"\u003eComplete Intro to Containers\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eFrom other amazing instructors\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eI want to get better at MongoDB from Scott Moss\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://frontendmasters.com/courses/mongodb/\"\u003eIntro to MongoDB (including Mongoose ORM)\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://frontendmasters.com/courses/api-design-nodejs-v3/\"\u003eAPI Design with MongoDB\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eI want to get better at GraphQL from Scott Moss\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://frontendmasters.com/courses/server-graphql-nodejs/\"\u003eFrom the server\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://frontendmasters.com/courses/client-graphql-react/\"\u003eFrom the client\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://frontendmasters.com/courses/advanced-graphql-v2/\"\u003eAdvance GraphQL\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://frontendmasters.com/courses/fullstack-v2/\"\u003eI want to get better at managing servers and cloud deployments\u003c/a\u003e from Jem Young\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eWrap Up\u003c/h2\u003e\n\u003cp\u003eThank you for sticking through this tutorial and congrats on your unlocked achievement of understanding databases! Be sure tweet at me your success \u003ca href=\"https://twitter.com/holtbt\"\u003ehere\u003c/a\u003e. And if you found issues, particularly with grammar, \u003ca href=\"https://github.com/btholt/complete-intro-to-databases\"\u003eopen a pull request!\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eI hope you enjoyed the course!\u003c/p\u003e\n","markdown":"\nCongratulations! You survived a tidal wave of information coming your way about how to store data in a variety different settings. You have enough context now to make a good judgment call on the best way to store you data n a variety of different settings and needs. Let's go over a few more considerations for you to make as you're considering decisions to choose when and where.\n\n## Paradigm\n\nHaving a decent amount of familiarity with the databases I've shown you as well as a few others, the first thing I stop to think about with which database I want to use with a project is what paradigm of data do I have?\n\n- Do I have highly relational data where I'll many tables that need to join to other tables? SQL/Relational databases are probably best here\n- Do I have highly unstructured data where I'll have collections of related objects that are differently shaped? Document-based databases are going to shine here\n- Do I have data where I need to describe graphs of relationships? A graph database can work best here\n- Do I have simple needs of just retreiving data based on keys? Key-value stores can be a primary database in these cases\n- Do I have pipelines of information that need to filter, split, combined, and republished? Something like [Apache Kafka][kafka] could be really helpful here\n\nDo none, some, or all of these fit? Do you have other considerations? Take a second to consider all of your data needs.\n\n## Read-Heavy vs Write-Heavy\n\nThis has as much to do with _which database_ you're choosing as it does with _how you architect_ your data with whatever database you're choosing.\n\nHere's a great example (shout to my conversation with [Harry Wolff], director at MongoDB Inc that inspired this.) If you have relational data but it's almost never read and more frequently read and your other usecases are more favored to using a document-based database, MongoDB is actually a fine choice to make in that case. MongoDB does do joins, it's just not so optimized as something like PostgreSQL is for it.\n\nThink a lot about where your hotspots of reads and writes are. Optimize for those. You can tolerate slowness and inefficiency in areas where they don't get run frequently.\n\nAlso recognize that you can rarely anticipate fully where your hotspots and non-hotspots are going to be in advance so be flexible.\n\n## Familiarity\n\nPeople don't put enough weight into familiarity. We think as developer we can pick anything at the drop of a hat and that just isn't true. Learning new tech is expensive, both from a time perspective and from you're-going-to-cause-downtime-because-you-don't-know-all-the-problems perspective. I remember at Reddit we went with MySQL despite PostgreSQL being all the hotness at the time because the entire team had familiarity with MySQL and no one knew PostgreSQL at all. Be sure to properly weigh experience into your decision. Some knowledge is only won through experience.\n\n## Quality of Drivers\n\nBe sure to be poke around the SDKs / drivers of whatever database you may choose with the language you're going to use. If MongoDB is amazing but their Elixir SDK is nonexistant or bad (I have no idea if it, just making an example) then no matter how good the database is you're still going to be fighting the SDK. Do the homework here and you'll save yourself some pain.\n\n## Ops Cost\n\nDatabases frequently end up being the most expensive part of your app from all perspectives: raw cost, raw time spent writing code for it, and cost of eventual downtime. Take a look at it from the perspective of how much it's going to cost you to hire ops people that know how to run this particular server in production.\n\nIn this capacity, and very biasedly, I recommend you look into using a cloud-based database. While the monetary cost of paying for a managed database-as-a-service is higher than just running a few VMs, not having to manage sharding, clusters, peering, elections, networking, firewalls, software updates, operating system updates, capacity allocations, horizontal scaling, vertical scaling, etc. frequently can make it more-than worth the cost. Again, I'm biased here due to my current employment at Microsoft Azure, but this is what I would choose even I wasn't employed here. All major cloud providers have great options here.\n\n## Be Boring\n\nI can't stress this enough. With your core infrastructure (a.k.a. anything that if it went down your app would go down) be as boring as you can tolerate. Instead of choosing what's hot, what's on Hacker News, what's being talked about on Twitter, what people are talking about at conferences, etc. just choose boring, tried-and-true technologies. Everything I've shown you here I think is mature enough to be considered boring. But make it boring to you by using them, finding problems, breaking them, and trying new things with them. Then they'll be boring for you too.\n\nIf you're going to do something exciting, have a damn good reason why it's much better than a boring alternative. On the bleeding edge, you're the one who is bleeding.\n\n## Caching\n\nWe went over caching a bit but I wanted to say a few things about it.\n\nCaching is a very, very hard problem and causes a lot of problems. Make sure you _need_ caching before you just throw it in there. Don't assume you need caching. Need caching before you put it in. It's hard to know when to cache, how to long to cache, when to invalidate caches, when not to, etc. It's just hard and make sure you need it.\n\nCaching is frequently a band-aid on a worse problem. Instead of fixing inefficiencies in a system that would obviate the need for caching people just throw a cache in front of something and ignore the problems in their systems. This often leads to bigger problems. Again, validate the need for caching and ask the question \"if I just improved the performance of this system would I still need caching?\"\n\nA big reason I throw out so much caution for caching is that databases are built to handle a lot of load and if you use them with best practices you can get a lot of performance out of them. Problems often arise because we're not using the tools correctly (like writing bad queries or having something misconfigured) and if we can fix these we can achieve greater scale without the need for a cache.\n\nCaching just adds so much indirection to your app. Now you whenever your API isn't responding correctly, you have to ask yourself \"is this a stale cache?\" God forbid you have multiple layers of caching (maybe you cache the database response, the external API response, and then cache the API response before it goes out) then you need to pick apart which cache was stale or if it's an underlying problem. It's also hard to avoid thundering herd problems. I taught you caching for a reason because sometimes we just do need it but it's a sharp implement; make sure you only use it when you actually need it and keep it as simple as you can.\n\n## Next Courses to Take\n\nFrontend Masters has so many wonderful courses and instructors to offer. Here a handful of ones that I'd recommend after taking this one if you want to further deepen skills\n\n### From me, Brian Holt\n\n- I want to get better at the command line: [Complete Intro to Linux and the CLI][cli]\n- I want to learn about the containers we've been using this whole time: [Complete Intro to Containers][containers]\n\n### From other amazing instructors\n\n- I want to get better at MongoDB from Scott Moss\n  - [Intro to MongoDB (including Mongoose ORM)][intro-mongo]\n  - [API Design with MongoDB][mongo]\n- I want to get better at GraphQL from Scott Moss\n  - [From the server][server-graphql]\n  - [From the client][client-graphql]\n  - [Advance GraphQL][advance-graphql]\n- [I want to get better at managing servers and cloud deployments][full-stack] from Jem Young\n\n## Wrap Up\n\nThank you for sticking through this tutorial and congrats on your unlocked achievement of understanding databases! Be sure tweet at me your success [here][twitter]. And if you found issues, particularly with grammar, [open a pull request!][pr]\n\nI hope you enjoyed the course!\n\n[kafka]: https://kafka.apache.org/\n[harry]: https://twitter.com/hswolff/\n[twitter]: https://twitter.com/holtbt\n[pr]: https://github.com/btholt/complete-intro-to-databases\n[mongo]: https://frontendmasters.com/courses/api-design-nodejs-v3/\n[cli]: https://frontendmasters.com/courses/linux-command-line/\n[containers]: https://frontendmasters.com/courses/complete-intro-containers/\n[advance-graphql]: https://frontendmasters.com/courses/advanced-graphql-v2/\n[intro-mongo]: https://frontendmasters.com/courses/mongodb/\n[full-stack]: https://frontendmasters.com/courses/fullstack-v2/\n[client-graphql]: https://frontendmasters.com/courses/client-graphql-react/\n[server-graphql]: https://frontendmasters.com/courses/server-graphql-nodejs/\n","slug":"conclusion","title":"Conclusion","section":"Conclusion","icon":"info-circle","filePath":"/home/runner/work/complete-intro-to-databases-v2/complete-intro-to-databases-v2/lessons/06-conclusion/A-conclusion.md","nextSlug":null,"prevSlug":"/lessons/key-value-store/redis-ops"}},"__N_SSG":true},"page":"/lessons/[section]/[slug]","query":{"section":"conclusion","slug":"conclusion"},"buildId":"Ogv8p-BwCHRQ1PzRpAU9u","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>