<!DOCTYPE html><html><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width" data-next-head=""/><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png" data-next-head=""/><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png" data-next-head=""/><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png" data-next-head=""/><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png" data-next-head=""/><link rel="icon" type="image/x-icon" href="/images/favicon.ico" data-next-head=""/><title data-next-head="">Neo4j – Complete Intro to Databases v2</title><meta name="description" content="Graph databases are great when you need to define relations between objects that can have complex webs of relations especially for things like social networks." data-next-head=""/><meta name="keywords" content="postgres,sql,redis,mongodb,neo4j,database,data,agents" data-next-head=""/><meta name="og:description" content="Graph databases are great when you need to define relations between objects that can have complex webs of relations especially for things like social networks." data-next-head=""/><meta name="og:title" content="Neo4j – Complete Intro to Databases v2" data-next-head=""/><meta name="og:image" content="/images/social-share-cover.jpg" data-next-head=""/><meta name="twitter:card" content="summary_large_image" data-next-head=""/><link data-next-font="size-adjust" rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/_next/static/chunks/3802a39ca373f962.css" as="style"/><link rel="stylesheet" href="/_next/static/chunks/3802a39ca373f962.css" data-n-g=""/><noscript data-n-css=""></noscript><script src="/_next/static/chunks/dbe15a90055bd265.js" defer=""></script><script src="/_next/static/chunks/49c75c2ed6206f46.js" defer=""></script><script src="/_next/static/chunks/da0ff8adaa6cce90.js" defer=""></script><script src="/_next/static/chunks/turbopack-342361b32f83e6b6.js" defer=""></script><script src="/_next/static/chunks/f189af6b04c7fd39.js" defer=""></script><script src="/_next/static/chunks/turbopack-8b35dea75ba6f85c.js" defer=""></script><script src="/_next/static/Ogv8p-BwCHRQ1PzRpAU9u/_ssgManifest.js" defer=""></script><script src="/_next/static/Ogv8p-BwCHRQ1PzRpAU9u/_buildManifest.js" defer=""></script></head><body><script async="" defer="" src="https://a.holt.courses/latest.js"></script><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"/><div id="__next"><link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&amp;display=swap" rel="stylesheet"/><div class="remix-app"><header class="navbar"><h1 class="navbar-brand"><a href="/">Complete Intro to Databases v2</a></h1><div class="navbar-info"><a href="https://frontendmasters.com/workshops/databases-v2/" class="cta-btn">Watch on Frontend Masters</a></div></header><div class="content-container"><div class="main"><div class="lesson-container"><div class="lesson"><div class="lesson-content"><p>Let&#39;s get our database up and running! Run the following.</p>
<pre><code class="hljs language-bash">docker run -dit --<span class="hljs-built_in">rm</span> --name=my-neo4j -p 7474:7474 -p 7687:7687 --<span class="hljs-built_in">env</span>=NEO4J_AUTH=none neo4j:4.1.3
</code></pre><p>This will spin up a new instance of Neo4j in docker and expose both its HTTP client and its querying port. We&#39;re going to start by querying the commandline called <code>cypher-shell</code> and then we&#39;ll move on to the awesome browser experience.</p>
<p>First thing to know is that the database is called Neo4j and the query language is called Cypher, just like the database is PostgreSQL and the query language is SQL. There are other graph query langauges like Gremlin but we&#39;ll just be talking Cypher today.</p>
<p>So let&#39;s get connected. Run the following:</p>
<pre><code class="hljs language-bash">docker <span class="hljs-built_in">exec</span> -it my-neo4j cypher-shell
</code></pre><p>This should drop you into an interactive with Neo4j. The first thing we&#39;re going to do is use a CREATE statement to make our first actor, Michael Cera. I love the movie Scott Pilgrim vs. the World so we&#39;re going to describe the actors in it here.</p>
<pre><code class="hljs language-cql">CREATE (Person {name:&#x27;Michael Cera&#x27;, born:1988});
</code></pre><p>You can see we created a new node with a label of Person and two attributes: a name of Michael Cera and a birth year of 1988. CREATE (Person {name:&#39;Michael Cera&#39;, born:1988});</p>
<p>Now what if we want to find that same record?</p>
<pre><code class="hljs language-cql">MATCH (p {name: &quot;Michael Cera&quot;}) RETURN p;
</code></pre><ul>
<li>Now we&#39;re using a shorthand variable, <code>p</code>. We could call this anything.</li>
<li>The first part reprsents what we&#39;re querying for. We didn&#39;t specify what label it was going to be but we have. Then it would look like <code>MATCH (p {name: &quot;Michael Cera&quot;}) RETURN p;</code></li>
<li>You need the return at the end or you wouldn&#39;t get anything back.</li>
</ul>
<p>Let&#39;s create a movie and then query for it.</p>
<pre><code class="hljs language-cql">CREATE (m:Movie {title: &#x27;Scott Pilgrim vs the World&#x27;, released: 2010, tagline: &#x27;An epic of epic epicness.&#x27; }) RETURN m;
</code></pre><ul>
<li>This will create and return all in the same query because there&#39;s no semicolon so it&#39;s treated as one query.</li>
<li>It&#39;s easy to make big complicated queries with Cypher.</li>
</ul>
<p>Let&#39;s now make them associated with each other so that Michael Cera acted in Scott Pilgrim vs the World.</p>
<pre><code class="hljs language-cql">MATCH (Michael:Person),(ScottVsWorld:Movie)
WHERE Michael.name = &quot;Michael Cera&quot; AND ScottVsWorld.title = &quot;Scott Pilgrim vs the World&quot;
CREATE (Michael)-[relationship:ACTED_IN {roles:[&quot;Scott Pilgrim&quot;]}]-&gt;(ScottVsWorld)
RETURN relationship;
</code></pre><ul>
<li>The first match says we&#39;re looking for two separate things, a Person and a Movie.</li>
<li>We then give a WHERE (there are a few ways to write queries that all work).</li>
<li>We then identify that we&#39;re going to CREATE something new.</li>
<li>This reads like ASCII art You have (node) - [RELATIONSHIP] -&gt; (node). This identifies that Michael ACTED_IN Movie. The -&gt; identifies the direction of the relationship. We also can totally right it as (Scott Pilgrim vs the World) &lt;- [ACTED_IN] - (Michael Cera). Both work.</li>
<li><code>relationship</code> is a variable that refers to the new relationship we just created. It&#39;s optional but I wanted to return it at the end.</li>
<li>Neo4j recommends you do CapitalCasing with label names (like Person and Movie) and that you SCREAMING_CASE relationship types (like DIRECTED and ACTED_IN.) I just follow their recommendations. <a href="https://neo4j.com/docs/cypher-manual/4.1/syntax/naming/">See here</a>.</li>
</ul>
<p>Okay, so let&#39;s put a few more relationships to the movie in. Copy/paste this to add a few more actors, actresses, and the director. (How many good actors and actresses were in Scott Pilgrim!?)</p>
<pre><code class="hljs language-cql">MATCH (ScottVsWorld:Movie) WHERE ScottVsWorld.title = &quot;Scott Pilgrim vs the World&quot;
CREATE (Anna:Person {name:&#x27;Anna Kendrick&#x27;, born:1985})
CREATE (Brie:Person {name:&#x27;Brie Larson&#x27;, born:1989})
CREATE (Aubrey:Person {name:&#x27;Aubrey Plaza&#x27;, born:1984})
CREATE (Mary:Person {name:&#x27;Mary Elizabeth Winstead&#x27;, born:1984})
CREATE (Kieran:Person {name:&#x27;Kieran Culkin&#x27;, born:1982})
CREATE (Chris:Person {name:&#x27;Chris Evans&#x27;, born:1981})
CREATE (Edgar:Person {name:&#x27;Edgar Wright&#x27;, born:1974})
CREATE
(Anna)-[:ACTED_IN {roles:[&#x27;Stacey Pilgrim&#x27;]}]-&gt;(ScottVsWorld),
(Brie)-[:ACTED_IN {roles:[&#x27;Envy Adams&#x27;]}]-&gt;(ScottVsWorld),
(Aubrey)-[:ACTED_IN {roles:[&#x27;Julie Powers&#x27;]}]-&gt;(ScottVsWorld),
(Mary)-[:ACTED_IN {roles:[&#x27;Ramona Flowers&#x27;]}]-&gt;(ScottVsWorld),
(Kieran)-[:ACTED_IN {roles:[&#x27;Wallace Wells&#x27;]}]-&gt;(ScottVsWorld),
(Chris)-[:ACTED_IN {roles:[&#x27;Lucas Lee&#x27;]}]-&gt;(ScottVsWorld),
(Edgar)-[:DIRECTED]-&gt;(ScottVsWorld);
</code></pre><p>Shouldn&#39;t be anything too surprising, just a lot of stuff being added at once.</p>
<p>So let&#39;s do a relationship query now. Find all movies Aubrey Plaza has acted in according to our database.</p>
<pre><code class="hljs language-cql">MATCH (p:Person)-[:ACTED_IN]-&gt;(m:Movie)
WHERE p.name = &quot;Aubrey Plaza&quot;
RETURN m.title;
</code></pre><ul>
<li>It&#39;s actually pretty easy when you see it written out. That&#39;s one of the nice parts of Cypher is that it reads well for the most part. It can start having a lot of <code>([{}])</code> which can get to be a bit much.</li>
<li>The <code>&gt;</code> part of <code>-&gt;</code> is optional. If you omit the direction in the query it just assumes you&#39;re saying &quot;find me a relationship here, I don&#39;t care which way the direction goes.&quot;</li>
</ul>
<p>One thing you&#39;ll notice is that Aubrey Plaza isn&#39;t connected to any of the other people directly, just via being attached to the same movie. What if we wanted to find every person who acted in the same movie as Aubrey (in this case everyone we&#39;ve added so far.)</p>
<pre><code class="hljs language-cql">MATCH (p:Person)-[:ACTED_IN]-&gt;(Movie)&lt;-[:ACTED_IN]-(q:Person)
WHERE p.name = &quot;Aubrey Plaza&quot; AND q.name &lt;&gt; &quot;Aubrey Plaza&quot;
RETURN q.name;
</code></pre><ul>
<li>There you go! We just describe out the relationship a bit further and use those variables.</li>
<li><code>&lt;&gt;</code> is how you do not equals in Cypher</li>
<li>Technically Aubrey was in the movie with herself? In any case we have to say don&#39;t include her in the results if we don&#39;t want to have her.</li>
</ul>
<p>But what if we wanted to find everyone who was younger than Aubrey that acted in the same movie?</p>
<pre><code class="hljs language-cql">MATCH (p:Person)-[:ACTED_IN]-&gt;(Movie)&lt;-[:ACTED_IN]-(q:Person)
WHERE p.name = &quot;Aubrey Plaza&quot; AND q.born &gt; p.born
RETURN q.name;
</code></pre><h2>Constraint</h2>
<p>Just like in the other databases you can enforce uniqueness which can be helpful. Here&#39;s how you&#39;d do that (though a bad idea in this case because there are lots of actors, actresses, and directors named the same thing as there are multiple movies called the same thing.)</p>
<pre><code class="hljs language-cql">CREATE CONSTRAINT ON (a:Person) ASSERT a.name IS UNIQUE;
CREATE CONSTRAINT ON (a:Movie) ASSERT a.title IS UNIQUE;
</code></pre></div><div class="lesson-links"><a class="prev" href="/lessons/graph/graph-databases">← Previous</a><a class="next" href="/lessons/graph/neo4j-browser">Next →</a></div></div><div class="details-bg"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="154" height="154" viewBox="0 0 154 154"><defs><clipPath id="clip-path"><rect id="Rectangle_2238" data-name="Rectangle 2238" width="154" height="154" transform="translate(9467 350)" fill="#fff" stroke="#707070" stroke-width="1"></rect></clipPath><clipPath id="clip-corner-image-active"><rect width="154" height="154"></rect></clipPath></defs><g id="corner-image-active" clip-path="url(#clip-corner-image-active)"><g id="Corner-image-active-2" data-name="Corner-image-active" transform="translate(-9467 -350)" clip-path="url(#clip-path)"><path id="Subtraction_34" data-name="Subtraction 34" d="M-3857.365,1740.766h0l-7.07-7.07,12.89-12.89v14.142l-5.818,5.818Zm-14.142-14.142h0l-7.071-7.07,27.033-27.033v14.143l-19.96,19.96Zm-14.143-14.143h0l-7.07-7.069,41.175-41.175v14.142Zm-14.142-14.142h0l-7.07-7.069,55.317-55.317v14.142Zm-14.142-14.142h0l-7.07-7.069,69.459-69.459v14.142Zm-14.142-14.142h0l-7.07-7.069,76.739-76.739h6.862v7.28Zm-14.143-14.143h0l-7.07-7.069,62.6-62.6h14.142Zm-14.142-14.142h0l-7.07-7.069,48.454-48.454h14.142Zm-14.142-14.142h0l-7.07-7.069,34.312-34.312h14.142Zm-14.142-14.142h0l-7.07-7.069,20.17-20.17h14.142Zm-14.142-14.142h0l-7.071-7.071,6.027-6.027h14.144l-13.1,13.1Zm367.24-56.114v-.909l.455.455-.453.453Z" transform="translate(13472.546 -1236.766)" fill="var(--corner-fill)"></path></g></g></svg></div></div></div></div><footer class="footer"><ul class="socials"><li class="social"><a href="https://twitter.com/holtbt"><svg fill="none" height="100%" width="32" xmlns="http://www.w3.org/2000/svg" viewBox="0.254 0.25 500 451.95400000000006"><path d="M394.033.25h76.67L303.202 191.693l197.052 260.511h-154.29L225.118 294.205 86.844 452.204H10.127l179.16-204.77L.254.25H158.46l109.234 144.417zm-26.908 406.063h42.483L135.377 43.73h-45.59z" fill="var(--footer-icons)"></path></svg></a></li><li class="social"><a href="https://bsky.app/profile/brianholt.me"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 -3.268 64 68.414" width="38" height="100%"><path fill="var(--footer-icons)" d="M13.873 3.805C21.21 9.332 29.103 20.537 32 26.55v15.882c0-.338-.13.044-.41.867-1.512 4.456-7.418 21.847-20.923 7.944-7.111-7.32-3.819-14.64 9.125-16.85-7.405 1.264-15.73-.825-18.014-9.015C1.12 23.022 0 8.51 0 6.55 0-3.268 8.579-.182 13.873 3.805zm36.254 0C42.79 9.332 34.897 20.537 32 26.55v15.882c0-.338.13.044.41.867 1.512 4.456 7.418 21.847 20.923 7.944 7.111-7.32 3.819-14.64-9.125-16.85 7.405 1.264 15.73-.825 18.014-9.015C62.88 23.022 64 8.51 64 6.55c0-9.818-8.578-6.732-13.873-2.745z"></path></svg></a></li><li class="social"><a href="https://github.com/btholt"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="32" height="32" viewBox="0 0 32 32"><defs><clipPath id="clip-github-social"><rect width="32" height="32"></rect></clipPath></defs><g id="github-social" clip-path="url(#clip-github-social)"><g id="Group_272" data-name="Group 272" transform="translate(13522.5 -6994)"><path id="Subtraction_33" data-name="Subtraction 33" d="M-24967.5,8041a15.9,15.9,0,0,1-11.312-4.688A15.893,15.893,0,0,1-24983.5,8025a15.893,15.893,0,0,1,4.689-11.315A15.894,15.894,0,0,1-24967.5,8009a15.894,15.894,0,0,1,11.313,4.686A15.893,15.893,0,0,1-24951.5,8025a15.893,15.893,0,0,1-4.689,11.313A15.9,15.9,0,0,1-24967.5,8041Zm-3.781-4.571h0v3.918h7.895v-6.665a1.836,1.836,0,0,0-1.2-1.718c5.1-.617,7.467-2.975,7.467-7.424a7.176,7.176,0,0,0-1.637-4.728,6.74,6.74,0,0,0,.275-1.812,4.34,4.34,0,0,0-.52-2.452.574.574,0,0,0-.359-.1c-1.061,0-3.465,1.411-3.936,1.694a16.644,16.644,0,0,0-4.2-.489,16.379,16.379,0,0,0-3.969.445c-.846-.5-2.91-1.649-3.859-1.649a.566.566,0,0,0-.354.095,4.3,4.3,0,0,0-.521,2.452,6.7,6.7,0,0,0,.244,1.718,7.346,7.346,0,0,0-1.6,4.822,7.263,7.263,0,0,0,1.533,4.985c1.193,1.359,3.115,2.165,5.871,2.464a1.826,1.826,0,0,0-1.129,1.693v.5h0l-.006,0a7.121,7.121,0,0,1-2.033.363,2.608,2.608,0,0,1-.965-.158,4.438,4.438,0,0,1-1.836-1.881,2.361,2.361,0,0,0-1.248-1.091,3.472,3.472,0,0,0-1.217-.3.584.584,0,0,0-.545.224.282.282,0,0,0,.027.367,1.875,1.875,0,0,0,.447.307,4.732,4.732,0,0,1,.561.355,10.726,10.726,0,0,1,1.682,2.755c.043.092.078.163.105.217a3.876,3.876,0,0,0,2.42,1.185,6.036,6.036,0,0,0,.607.025c.875,0,1.988-.124,2-.125Z" transform="translate(11461 -1015)" fill="var(--footer-icons)"></path><g id="Ellipse_670" data-name="Ellipse 670" transform="translate(-13522.5 6994)" fill="none" stroke="var(--footer-icons)" stroke-width="1"><circle cx="16" cy="16" r="16" stroke="none"></circle><circle cx="16" cy="16" r="15.5" fill="none"></circle></g></g></g></svg></a></li><li class="social"><a href="https://linkedin.com/in/btholt"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="32" height="32" viewBox="0 0 32 32"><defs><clipPath id="clip-linkedin-social"><rect width="32" height="32"></rect></clipPath></defs><g id="linkedin-social" clip-path="url(#clip-linkedin-social)"><g id="Group_270" data-name="Group 270" transform="translate(-86.349 -633.073)"><path id="Path_375" data-name="Path 375" d="M115.789,633.073a2.324,2.324,0,0,1,1.682.676,2.194,2.194,0,0,1,.695,1.627V662.8a2.131,2.131,0,0,1-.695,1.609,2.314,2.314,0,0,1-1.646.659H88.69a2.307,2.307,0,0,1-1.646-.659,2.128,2.128,0,0,1-.695-1.609V635.376a2.19,2.19,0,0,1,.695-1.627,2.322,2.322,0,0,1,1.682-.676h27.063Zm-20.224,9.672a2.561,2.561,0,0,0,0-3.584,2.658,2.658,0,0,0-1.938-.712,2.724,2.724,0,0,0-1.957.712,2.371,2.371,0,0,0-.75,1.792,2.4,2.4,0,0,0,.731,1.792,2.605,2.605,0,0,0,1.9.713h.037A2.7,2.7,0,0,0,95.565,642.745ZM96,645.434H91.213V659.88H96Zm17.3,6.144a7.007,7.007,0,0,0-1.573-4.9,5.68,5.68,0,0,0-6.839-.769,5.663,5.663,0,0,0-1.426,1.573v-2.048H98.674q.036.841,0,7.717v6.728h4.791V651.8a3.592,3.592,0,0,1,.146-1.17,2.913,2.913,0,0,1,.878-1.206,2.429,2.429,0,0,1,1.609-.549,2.108,2.108,0,0,1,1.865.914,4.265,4.265,0,0,1,.549,2.341v7.752H113.3Z" fill="var(--footer-icons)"></path></g></g></svg></a></li><li class="social"><div class="terms"><p>Content Licensed Under CC-BY-NC-4.0</p><p>Code Samples and Exercises Licensed Under Apache 2.0</p><p>Site Designed by<!-- --> <a href="https://www.alexdanielson.com/">Alex Danielson</a></p></div></li></ul><div class="theme-icons"><button aria-label="Activate dark mode" title="Activate dark mode" class="theme-toggle"><svg xmlns="http://www.w3.org/2000/svg" width="36px" height="100%" viewBox="0 -960 960 960" fill="var(--text-footer)" role="img"><title>Dark Mode Icon</title><path d="M480-120q-150 0-255-105T120-480q0-150 105-255t255-105q14 0 27.5 1t26.5 3q-41 29-65.5 75.5T444-660q0 90 63 153t153 63q55 0 101-24.5t75-65.5q2 13 3 26.5t1 27.5q0 150-105 255T480-120Zm0-80q88 0 158-48.5T740-375q-20 5-40 8t-40 3q-123 0-209.5-86.5T364-660q0-20 3-40t8-40q-78 32-126.5 102T200-480q0 116 82 198t198 82Z"></path></svg></button></div></footer></div><noscript><img src="https://a.holt.courses/noscript.gif" alt="" referrerPolicy="no-referrer-when-downgrade"/></noscript></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"attributes":{"title":"Neo4j","description":"Graph databases are great when you need to define relations between objects that can have complex webs of relations especially for things like social networks."},"html":"\u003cp\u003eLet\u0026#39;s get our database up and running! Run the following.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003edocker run -dit --\u003cspan class=\"hljs-built_in\"\u003erm\u003c/span\u003e --name=my-neo4j -p 7474:7474 -p 7687:7687 --\u003cspan class=\"hljs-built_in\"\u003eenv\u003c/span\u003e=NEO4J_AUTH=none neo4j:4.1.3\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis will spin up a new instance of Neo4j in docker and expose both its HTTP client and its querying port. We\u0026#39;re going to start by querying the commandline called \u003ccode\u003ecypher-shell\u003c/code\u003e and then we\u0026#39;ll move on to the awesome browser experience.\u003c/p\u003e\n\u003cp\u003eFirst thing to know is that the database is called Neo4j and the query language is called Cypher, just like the database is PostgreSQL and the query language is SQL. There are other graph query langauges like Gremlin but we\u0026#39;ll just be talking Cypher today.\u003c/p\u003e\n\u003cp\u003eSo let\u0026#39;s get connected. Run the following:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003edocker \u003cspan class=\"hljs-built_in\"\u003eexec\u003c/span\u003e -it my-neo4j cypher-shell\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis should drop you into an interactive with Neo4j. The first thing we\u0026#39;re going to do is use a CREATE statement to make our first actor, Michael Cera. I love the movie Scott Pilgrim vs. the World so we\u0026#39;re going to describe the actors in it here.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-cql\"\u003eCREATE (Person {name:\u0026#x27;Michael Cera\u0026#x27;, born:1988});\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eYou can see we created a new node with a label of Person and two attributes: a name of Michael Cera and a birth year of 1988. CREATE (Person {name:\u0026#39;Michael Cera\u0026#39;, born:1988});\u003c/p\u003e\n\u003cp\u003eNow what if we want to find that same record?\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-cql\"\u003eMATCH (p {name: \u0026quot;Michael Cera\u0026quot;}) RETURN p;\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eNow we\u0026#39;re using a shorthand variable, \u003ccode\u003ep\u003c/code\u003e. We could call this anything.\u003c/li\u003e\n\u003cli\u003eThe first part reprsents what we\u0026#39;re querying for. We didn\u0026#39;t specify what label it was going to be but we have. Then it would look like \u003ccode\u003eMATCH (p {name: \u0026quot;Michael Cera\u0026quot;}) RETURN p;\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eYou need the return at the end or you wouldn\u0026#39;t get anything back.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eLet\u0026#39;s create a movie and then query for it.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-cql\"\u003eCREATE (m:Movie {title: \u0026#x27;Scott Pilgrim vs the World\u0026#x27;, released: 2010, tagline: \u0026#x27;An epic of epic epicness.\u0026#x27; }) RETURN m;\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eThis will create and return all in the same query because there\u0026#39;s no semicolon so it\u0026#39;s treated as one query.\u003c/li\u003e\n\u003cli\u003eIt\u0026#39;s easy to make big complicated queries with Cypher.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eLet\u0026#39;s now make them associated with each other so that Michael Cera acted in Scott Pilgrim vs the World.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-cql\"\u003eMATCH (Michael:Person),(ScottVsWorld:Movie)\nWHERE Michael.name = \u0026quot;Michael Cera\u0026quot; AND ScottVsWorld.title = \u0026quot;Scott Pilgrim vs the World\u0026quot;\nCREATE (Michael)-[relationship:ACTED_IN {roles:[\u0026quot;Scott Pilgrim\u0026quot;]}]-\u0026gt;(ScottVsWorld)\nRETURN relationship;\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eThe first match says we\u0026#39;re looking for two separate things, a Person and a Movie.\u003c/li\u003e\n\u003cli\u003eWe then give a WHERE (there are a few ways to write queries that all work).\u003c/li\u003e\n\u003cli\u003eWe then identify that we\u0026#39;re going to CREATE something new.\u003c/li\u003e\n\u003cli\u003eThis reads like ASCII art You have (node) - [RELATIONSHIP] -\u0026gt; (node). This identifies that Michael ACTED_IN Movie. The -\u0026gt; identifies the direction of the relationship. We also can totally right it as (Scott Pilgrim vs the World) \u0026lt;- [ACTED_IN] - (Michael Cera). Both work.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003erelationship\u003c/code\u003e is a variable that refers to the new relationship we just created. It\u0026#39;s optional but I wanted to return it at the end.\u003c/li\u003e\n\u003cli\u003eNeo4j recommends you do CapitalCasing with label names (like Person and Movie) and that you SCREAMING_CASE relationship types (like DIRECTED and ACTED_IN.) I just follow their recommendations. \u003ca href=\"https://neo4j.com/docs/cypher-manual/4.1/syntax/naming/\"\u003eSee here\u003c/a\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOkay, so let\u0026#39;s put a few more relationships to the movie in. Copy/paste this to add a few more actors, actresses, and the director. (How many good actors and actresses were in Scott Pilgrim!?)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-cql\"\u003eMATCH (ScottVsWorld:Movie) WHERE ScottVsWorld.title = \u0026quot;Scott Pilgrim vs the World\u0026quot;\nCREATE (Anna:Person {name:\u0026#x27;Anna Kendrick\u0026#x27;, born:1985})\nCREATE (Brie:Person {name:\u0026#x27;Brie Larson\u0026#x27;, born:1989})\nCREATE (Aubrey:Person {name:\u0026#x27;Aubrey Plaza\u0026#x27;, born:1984})\nCREATE (Mary:Person {name:\u0026#x27;Mary Elizabeth Winstead\u0026#x27;, born:1984})\nCREATE (Kieran:Person {name:\u0026#x27;Kieran Culkin\u0026#x27;, born:1982})\nCREATE (Chris:Person {name:\u0026#x27;Chris Evans\u0026#x27;, born:1981})\nCREATE (Edgar:Person {name:\u0026#x27;Edgar Wright\u0026#x27;, born:1974})\nCREATE\n(Anna)-[:ACTED_IN {roles:[\u0026#x27;Stacey Pilgrim\u0026#x27;]}]-\u0026gt;(ScottVsWorld),\n(Brie)-[:ACTED_IN {roles:[\u0026#x27;Envy Adams\u0026#x27;]}]-\u0026gt;(ScottVsWorld),\n(Aubrey)-[:ACTED_IN {roles:[\u0026#x27;Julie Powers\u0026#x27;]}]-\u0026gt;(ScottVsWorld),\n(Mary)-[:ACTED_IN {roles:[\u0026#x27;Ramona Flowers\u0026#x27;]}]-\u0026gt;(ScottVsWorld),\n(Kieran)-[:ACTED_IN {roles:[\u0026#x27;Wallace Wells\u0026#x27;]}]-\u0026gt;(ScottVsWorld),\n(Chris)-[:ACTED_IN {roles:[\u0026#x27;Lucas Lee\u0026#x27;]}]-\u0026gt;(ScottVsWorld),\n(Edgar)-[:DIRECTED]-\u0026gt;(ScottVsWorld);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eShouldn\u0026#39;t be anything too surprising, just a lot of stuff being added at once.\u003c/p\u003e\n\u003cp\u003eSo let\u0026#39;s do a relationship query now. Find all movies Aubrey Plaza has acted in according to our database.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-cql\"\u003eMATCH (p:Person)-[:ACTED_IN]-\u0026gt;(m:Movie)\nWHERE p.name = \u0026quot;Aubrey Plaza\u0026quot;\nRETURN m.title;\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eIt\u0026#39;s actually pretty easy when you see it written out. That\u0026#39;s one of the nice parts of Cypher is that it reads well for the most part. It can start having a lot of \u003ccode\u003e([{}])\u003c/code\u003e which can get to be a bit much.\u003c/li\u003e\n\u003cli\u003eThe \u003ccode\u003e\u0026gt;\u003c/code\u003e part of \u003ccode\u003e-\u0026gt;\u003c/code\u003e is optional. If you omit the direction in the query it just assumes you\u0026#39;re saying \u0026quot;find me a relationship here, I don\u0026#39;t care which way the direction goes.\u0026quot;\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOne thing you\u0026#39;ll notice is that Aubrey Plaza isn\u0026#39;t connected to any of the other people directly, just via being attached to the same movie. What if we wanted to find every person who acted in the same movie as Aubrey (in this case everyone we\u0026#39;ve added so far.)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-cql\"\u003eMATCH (p:Person)-[:ACTED_IN]-\u0026gt;(Movie)\u0026lt;-[:ACTED_IN]-(q:Person)\nWHERE p.name = \u0026quot;Aubrey Plaza\u0026quot; AND q.name \u0026lt;\u0026gt; \u0026quot;Aubrey Plaza\u0026quot;\nRETURN q.name;\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eThere you go! We just describe out the relationship a bit further and use those variables.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026lt;\u0026gt;\u003c/code\u003e is how you do not equals in Cypher\u003c/li\u003e\n\u003cli\u003eTechnically Aubrey was in the movie with herself? In any case we have to say don\u0026#39;t include her in the results if we don\u0026#39;t want to have her.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eBut what if we wanted to find everyone who was younger than Aubrey that acted in the same movie?\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-cql\"\u003eMATCH (p:Person)-[:ACTED_IN]-\u0026gt;(Movie)\u0026lt;-[:ACTED_IN]-(q:Person)\nWHERE p.name = \u0026quot;Aubrey Plaza\u0026quot; AND q.born \u0026gt; p.born\nRETURN q.name;\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003eConstraint\u003c/h2\u003e\n\u003cp\u003eJust like in the other databases you can enforce uniqueness which can be helpful. Here\u0026#39;s how you\u0026#39;d do that (though a bad idea in this case because there are lots of actors, actresses, and directors named the same thing as there are multiple movies called the same thing.)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-cql\"\u003eCREATE CONSTRAINT ON (a:Person) ASSERT a.name IS UNIQUE;\nCREATE CONSTRAINT ON (a:Movie) ASSERT a.title IS UNIQUE;\n\u003c/code\u003e\u003c/pre\u003e","markdown":"\nLet's get our database up and running! Run the following.\n\n```bash\ndocker run -dit --rm --name=my-neo4j -p 7474:7474 -p 7687:7687 --env=NEO4J_AUTH=none neo4j:4.1.3\n```\n\nThis will spin up a new instance of Neo4j in docker and expose both its HTTP client and its querying port. We're going to start by querying the commandline called `cypher-shell` and then we'll move on to the awesome browser experience.\n\nFirst thing to know is that the database is called Neo4j and the query language is called Cypher, just like the database is PostgreSQL and the query language is SQL. There are other graph query langauges like Gremlin but we'll just be talking Cypher today.\n\nSo let's get connected. Run the following:\n\n```bash\ndocker exec -it my-neo4j cypher-shell\n```\n\nThis should drop you into an interactive with Neo4j. The first thing we're going to do is use a CREATE statement to make our first actor, Michael Cera. I love the movie Scott Pilgrim vs. the World so we're going to describe the actors in it here.\n\n```cql\nCREATE (Person {name:'Michael Cera', born:1988});\n```\n\nYou can see we created a new node with a label of Person and two attributes: a name of Michael Cera and a birth year of 1988. CREATE (Person {name:'Michael Cera', born:1988});\n\nNow what if we want to find that same record?\n\n```cql\nMATCH (p {name: \"Michael Cera\"}) RETURN p;\n```\n\n- Now we're using a shorthand variable, `p`. We could call this anything.\n- The first part reprsents what we're querying for. We didn't specify what label it was going to be but we have. Then it would look like `MATCH (p {name: \"Michael Cera\"}) RETURN p;`\n- You need the return at the end or you wouldn't get anything back.\n\nLet's create a movie and then query for it.\n\n```cql\nCREATE (m:Movie {title: 'Scott Pilgrim vs the World', released: 2010, tagline: 'An epic of epic epicness.' }) RETURN m;\n```\n\n- This will create and return all in the same query because there's no semicolon so it's treated as one query.\n- It's easy to make big complicated queries with Cypher.\n\nLet's now make them associated with each other so that Michael Cera acted in Scott Pilgrim vs the World.\n\n```cql\nMATCH (Michael:Person),(ScottVsWorld:Movie)\nWHERE Michael.name = \"Michael Cera\" AND ScottVsWorld.title = \"Scott Pilgrim vs the World\"\nCREATE (Michael)-[relationship:ACTED_IN {roles:[\"Scott Pilgrim\"]}]-\u003e(ScottVsWorld)\nRETURN relationship;\n```\n\n- The first match says we're looking for two separate things, a Person and a Movie.\n- We then give a WHERE (there are a few ways to write queries that all work).\n- We then identify that we're going to CREATE something new.\n- This reads like ASCII art You have (node) - \\[RELATIONSHIP] -\u003e (node). This identifies that Michael ACTED_IN Movie. The -\u003e identifies the direction of the relationship. We also can totally right it as (Scott Pilgrim vs the World) \u003c- \\[ACTED_IN] - (Michael Cera). Both work.\n- `relationship` is a variable that refers to the new relationship we just created. It's optional but I wanted to return it at the end.\n- Neo4j recommends you do CapitalCasing with label names (like Person and Movie) and that you SCREAMING_CASE relationship types (like DIRECTED and ACTED_IN.) I just follow their recommendations. [See here][naming].\n\nOkay, so let's put a few more relationships to the movie in. Copy/paste this to add a few more actors, actresses, and the director. (How many good actors and actresses were in Scott Pilgrim!?)\n\n```cql\nMATCH (ScottVsWorld:Movie) WHERE ScottVsWorld.title = \"Scott Pilgrim vs the World\"\nCREATE (Anna:Person {name:'Anna Kendrick', born:1985})\nCREATE (Brie:Person {name:'Brie Larson', born:1989})\nCREATE (Aubrey:Person {name:'Aubrey Plaza', born:1984})\nCREATE (Mary:Person {name:'Mary Elizabeth Winstead', born:1984})\nCREATE (Kieran:Person {name:'Kieran Culkin', born:1982})\nCREATE (Chris:Person {name:'Chris Evans', born:1981})\nCREATE (Edgar:Person {name:'Edgar Wright', born:1974})\nCREATE\n(Anna)-[:ACTED_IN {roles:['Stacey Pilgrim']}]-\u003e(ScottVsWorld),\n(Brie)-[:ACTED_IN {roles:['Envy Adams']}]-\u003e(ScottVsWorld),\n(Aubrey)-[:ACTED_IN {roles:['Julie Powers']}]-\u003e(ScottVsWorld),\n(Mary)-[:ACTED_IN {roles:['Ramona Flowers']}]-\u003e(ScottVsWorld),\n(Kieran)-[:ACTED_IN {roles:['Wallace Wells']}]-\u003e(ScottVsWorld),\n(Chris)-[:ACTED_IN {roles:['Lucas Lee']}]-\u003e(ScottVsWorld),\n(Edgar)-[:DIRECTED]-\u003e(ScottVsWorld);\n```\n\nShouldn't be anything too surprising, just a lot of stuff being added at once.\n\nSo let's do a relationship query now. Find all movies Aubrey Plaza has acted in according to our database.\n\n```cql\nMATCH (p:Person)-[:ACTED_IN]-\u003e(m:Movie)\nWHERE p.name = \"Aubrey Plaza\"\nRETURN m.title;\n```\n\n- It's actually pretty easy when you see it written out. That's one of the nice parts of Cypher is that it reads well for the most part. It can start having a lot of `([{}])` which can get to be a bit much.\n- The `\u003e` part of `-\u003e` is optional. If you omit the direction in the query it just assumes you're saying \"find me a relationship here, I don't care which way the direction goes.\"\n\nOne thing you'll notice is that Aubrey Plaza isn't connected to any of the other people directly, just via being attached to the same movie. What if we wanted to find every person who acted in the same movie as Aubrey (in this case everyone we've added so far.)\n\n```cql\nMATCH (p:Person)-[:ACTED_IN]-\u003e(Movie)\u003c-[:ACTED_IN]-(q:Person)\nWHERE p.name = \"Aubrey Plaza\" AND q.name \u003c\u003e \"Aubrey Plaza\"\nRETURN q.name;\n```\n\n- There you go! We just describe out the relationship a bit further and use those variables.\n- `\u003c\u003e` is how you do not equals in Cypher\n- Technically Aubrey was in the movie with herself? In any case we have to say don't include her in the results if we don't want to have her.\n\nBut what if we wanted to find everyone who was younger than Aubrey that acted in the same movie?\n\n```cql\nMATCH (p:Person)-[:ACTED_IN]-\u003e(Movie)\u003c-[:ACTED_IN]-(q:Person)\nWHERE p.name = \"Aubrey Plaza\" AND q.born \u003e p.born\nRETURN q.name;\n```\n\n## Constraint\n\nJust like in the other databases you can enforce uniqueness which can be helpful. Here's how you'd do that (though a bad idea in this case because there are lots of actors, actresses, and directors named the same thing as there are multiple movies called the same thing.)\n\n```cql\nCREATE CONSTRAINT ON (a:Person) ASSERT a.name IS UNIQUE;\nCREATE CONSTRAINT ON (a:Movie) ASSERT a.title IS UNIQUE;\n```\n\n[naming]: https://neo4j.com/docs/cypher-manual/4.1/syntax/naming/\n","slug":"neo4j","title":"Neo4j","section":"Graph","icon":"info-circle","filePath":"/home/runner/work/complete-intro-to-databases-v2/complete-intro-to-databases-v2/lessons/04-graph/B-neo4j.md","nextSlug":"/lessons/graph/neo4j-browser","prevSlug":"/lessons/graph/graph-databases"}},"__N_SSG":true},"page":"/lessons/[section]/[slug]","query":{"section":"graph","slug":"neo4j"},"buildId":"Ogv8p-BwCHRQ1PzRpAU9u","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>